# Programming
- Def1 : A set of instructions is known as a program and the act of creating a program is known as programming Programs are created to solve the problems, to automate the processes and to reduce repetitive and/or manual work.
- Def2 : A program is a collection of instructions that performs a specific task when executed by a computer.

# Algorithm 
- Set of steps

# Java 
- High-level programming languages

# Compiler and interpreter 
- Which converts code into binary language. Computer Cannot understand high level language, they understand only binary language i.e. 0 and 1. Conversion is possible uisng system software called compilers and interpreters. In Java, the program (source code) written by the programmer gets compiled and converted into byte code (compiled code) by the Java compiler. 
- All the byte codes required for the program are then given to the interpreter. The interpreter reads the byte code line by line, converts it to binary form, also called as machine language or binary language, and then executes it.
- This process requires some support and an environment for the execution to happen. JDK (Java Development Kit) helps in this for execution of a Java program. It provides library support and Java Runtime Environment (JRE), the environment for developing and executing Java based applications and programs.

# Hello world program in java
```
class Welcome {
	public static void main(String[] args) {
		System.out.println("Hello World! Welcome to Java Programming!");
	}
}
```

The program displays a message - 'Hello World! Welcome to Java Programming!'. Here are some of the syntax rules of Java language:

- The message is displayed using System.out.println which is used for displaying messages or output in Java.

- Every statement in Java program must end with semicolon (;).

- Every statement in Java must be present inside a method. A method is a block of code that performs a particular task.

- In the code given above, the method is named as main. Every program in Java must have a main method as the code execution starts from the main method.  

- The method is defined using curly braces ({}). { signifies the start of a code block and } signifies its end.

- Every method in Java must be present inside a class. In the code given above, the class is named as Welcome. You will learn about classes and methods in detail later in the course.

- Java is a case-sensitive programming language. E.g. - The word class should be written in lower case.

# JDK

The development, compilation and execution of Java programs is taken care by JDK which contains 2 main components: Development tools and JRE.

The development tools consist of Java compiler and Java launcher.

- Java compiler (javac.exe) - It is the primary Java compiler. The compiler accepts Java source code and produces Java bytecode conforming to the Java Virtual Machine Specification (JVMS).

- Java launcher (java.exe) - It helps in launching a Java application during execution.

Next, let us discuss about Java Runtime Environment (JRE).

The Java Runtime Environment (JRE) contains Java Virtual Machine(JVM) and the Java standard library (Java Class Library).

- Java Virtual Machine (JVM) - It is the virtual machine that enables the computer to run Java programs.

- Java standard library (Java Class Library) - It is a set of dynamically loadable libraries that Java applications can call at run time. Java Platform is not dependent on a specific operating system and hence applications cannot rely on any of the platform-native libraries. So, the Java Platform provides a set of standard class libraries containing functions common to modern operating systems.

how does a Java program get executed by the computer.

- The Java source code is saved in a file with .java extension. When we compile a Java program (.java file), .class files (byte code) with the same class names present in .java file are generated by the Java compiler (javac). These .class files go through various steps when we run the program as shown in the below diagram.

## Platform Indepent

If a program written on a particular platform can run on other platforms without any recompilation, it is known as a platform independent program.

Usually larger applications are created by a team of developers. While most of them could be working on the same operating system such as Windows, others might be using different operating systems like Mac or Linux. In this scenario, we might have a situation where a program written on Windows needs to be executed on Mac OS also. 

Since Java is platform independent, it is not a problem. A program written using Java on Windows will execute without any recompilation on any other platform.

## Features
- Simple
- Robust
- Architecchural Neutral
- Secure
- Mutlti threaded

# Program
```
class Tester {
	public static void main(String[] args) {
		// Implement your code here 
		int principal = 5000, rate = 10, time = 5;
		System.out.println((principal*rate*time)/100)
		
	}
}
```

Implement a program to find and display the maximum number out of the given three numbers

```
class Tester {
	public static void main(String[] args) {
		// Implement your code here 
		int num1 = 3, num2 = 4, num3 = 1;
		if ((num1 > num2) && (num1 > num3)){
		    System.out.println(num1);
		}else if((num2 > num1) && (num2 > num3)){
		    System.out.println(num2);
		}else{
		    System.out.println(num3);
		}
	}
}

```

# OOP

- Object Oriented Programming(OOP) is a type of programming approach which enables the programmers to work with real life entities like Customer, Trainee, Employee, Company, Product, Food, Book, etc.

- Java, C#, Simula, JavaScript, Python, C++, Visual Basic .NET, Ruby, Scala, PHP etc. are some of the popular object-oriented programming languages.

- OOP helps a programmer in breaking down the code into smaller modules. These modules (classes) will have state(represented by attributes/variables) and functionality (represented by behavior/methods).

- These modules can then be used for representing the individual real life entities known as objects.

- E.g. - We can have a class named Customer to represent the state and behavior of all customers. Each individual customer can then be represented using an object of the Customer class.

# Access Modifier:
- So far, you have been using "public" and "private" keywords in your code. These keywords are called access modifiers.

- You will now understand them in more details.

- They are used to specify access levels to control the visibility of a class and its members. This facilitates encapsulation. There are 4 such access modifiers in Java:

1. Public: Accessible from any other class

2. Private: Accessible only inside its own class

3. Protected: Accessible inside the same package and to the sub-classes in different packages. This will be discussed in detail later in the course.

4. Default: Accessible inside the same package. Members created without any access modifier will have this access.


# Array

- An array is a collection of values of the same data type, stored in contiguous memory locations and referred by the same name. It holds a fixed number of values, decided at the time of array declaration.

- In order to use array in Java, you need to declare an array along with a datatype. You can declare, create and initialize an array in the following ways:

- Declaring and initializing the array in one line:
- Syntax:
```
dataType[ ] arrayVarName = {elementsOfArraySeparatedByComma};
```
- Eg:
```
long[ ] restaurantContacts = { 9992346725L, 9992346726L, 9992346727L };
```
- Creating the array using new: 
- Syntax:
```
dataType[ ] arrayVarName = new dataType[size];
arrayVarName[index] = element;
```
- E.g.:
```
long[ ] restaurantContacts = new long [3]; // Creating an array of size 3 of long datatype
restaurantContacts [0] = 9992346725L;
restaurantContacts [1] = 9992346726L;
restaurantContacts [2] = 9992346727L;
```
- Declaring and creating the array in different lines: 
- Syntax:
```
dataType [] arrayVarName;
arrayVarName = new dataType[size];
arrayVarName[index] = element;
```
- E.g.:
```
long[] restaurantContacts;
restaurantContacts = new long[3];
restaurantContacts[0] = 9992346725L;
restaurantContacts[1] = 9992346726L;
restaurantContacts[2] = 9992346727L;
```

### Accessing the elements of an array

- Each value stored in an array is called as an element. Each element in an array is accessed, stored and retrieved using its position in the array, called index. Indexes in Java are zero-based, i.e., the valid range of indexes for the elements of an array is from 0 to (size of Array-1).

```
long[] restaurantContacts = new long[3];
restaurantContacts [0] = 9992346725L; // Elements can be updated and accessed with the help of index
restaurantContacts [1] = 9992346726L;
restaurantContacts [2] = 9992346727L;
System.out.println(restaurantContacts [1]) ;// Accessing and displaying the element at the 1st index  

```

### Using for loop

Instead of writing n number of lines to access n elements of an array, you can use different looping constructs like for loop, for-each loop, etc.

The below code shows how to access and display the elements of restaurantContacts with the help of for loop.
```
public class Tester {
	public static void main(String[] args) {
		long[] restaurantContacts = { 9992346725L, 9992346726L, 9992346727L };
		for (int index = 0; index < restaurantContacts.length; index++) {
			// Accessing element at position index
			System.out.println(restaurantContacts[index]);
		}
	}
}
```
Note: - The length attribute of an array is used to get its size

Java also has another loop known as for-each loop to iterate over collections. This eliminates the use of indexes. It displays the array elements one by one. It holds an array element in a variable and then executes the body of the loop.

Syntax:
```
for (dataType variable: array) { 
	//body of the loop 
} 
```
The below code displays the elements of restaurantContacts array using the for-each loop.
```
public class Tester {
	public static void main(String[] args) {
		long[] restaurantContacts = { 9992346725L, 9992346726L, 9992346727L };
		for (long contactNumber : restaurantContacts) {
			System.out.println(contactNumber);
		}
	}
}
```

# Multi dimensional Array

Next, you will learn about Multi-dimensional arrays.

Multi-dimensional arrays are arrays of arrays with each element of the array holding the reference of other arrays. A multi-dimensional array is created by appending one set of square brackets ([]) per dimension.

Let's see a simple example to declare, instantiate, initialize and display a 2-dimensional (2D) array.

Syntax for creating 2D array:
```
dataType[][] arrayVarName = new dataType[rowsize][columnsize];
```
Note: The second dimension, i.e., the column size is optional.

E.g.
```
//Here, the row size is 7, and the column size is 2
//The 0th index stores the Max temperature and 1st index stores the Min temperature
int[][] dayWiseTemperature = new int[7][2];    
dayWiseTemperature[0][0]=29; // Initialization 
dayWiseTemperature[0][1]=21;
//and so on
//Another way of creating and initializing 2D array 
int[][] dayWiseTemperature = new int[][]  {{29,21},
		{24,23},
		{26,22},
		{28,23},
		{29,24},
		{23,20},
		{29,21}};
```

The below code shows how to update and display an element of a 2D array
```
//Updating an element of a 2D array 
dayWiseTemperature[2][0]=33;
//Displaying value of an element of a 2D array 
System.out.println(dayWiseTemperature[2][0]); 
```

# Points

Some of the important points that you should be knowing about arrays are:

- An array is a collection of similar data in contiguous memory locations referred by the same name

- Can be used to store data of primitive as well as reference types

- Holds a fixed number of values, determined at the time of array declaration

- Array index always starts from zero

- The length attribute of an array can be used to get its size

- Once initialized, the size of an array cannot be changed

### Command Line argumnet

Now that you know arrays, you will be able to notice something familiar in the code that you have already seen.
```
public static void main( String[] args) {
		// Code 
	}
```
String args[] is an array of strings. 

How are values passed to this array?

Values are passed to this array using command-line arguments. Such arguments are passed as inputs to your program either through the command prompt of your system or through the run configuration of your IDE.

Create a class named Greetings as shown below.
```
public class Greetings{
     public static void main(String[] args){
          System.out.println("Hello"+args[0]);
     }
}
```
The main method accepts inputs through the String[] args and displays the output using it.

# String

- String is used to store a sequence of characters. String is a predefined class in Java and comes with many methods which can help us perform various operations on it. 

- There are two ways to create a string: 

1. String literal 
```
        String customerName = "Jasmine"; 
```
2. Using new() keyword 
```
        String customerName = new String("Jasmine"); 
```

- Every time you create a string literal, the JVM checks the String constant pool. String constant pool in Java is a pool of Strings stored in Heap memory. If the string exists in the pool, then a reference to the existing literal is returned. If the string is not found, then a new instance is created and placed in the pool. 

- In the below diagram, since the value of newName is also Max, new memory is not allocated for newName and newName points to the same memory location as name does.

- String name = "MAX"
- String newName = "MAX"
- In name==newName will be true.

- Strings behave a bit differently when a new instance of String class is created. When you create a string using the new() keyword, JVM places the literal in the constant pool and also creates a new string object in heap memory. The reference variable points to the object in the heap memory.

- In the below example, either 1 or 2 strings will be created. If there is already a string literal "Welcome" in the pool, then only one string will be created. If there is no string literal "Welcome" in the pool, then it will be first created in the pool and then in the heap memory resulting in creation of 2 String objects. 

- String str = new String("Welcome")
- String newStr = new String("Welcome")
- str == newStr will be false.

## Debugging

pending

# Static
- When a variable is declared as Static, then a single copy of the variable is created and shared among all objects at the class level. Memory allocation for such variables happen only once when the class is loaded in the memory. These variables are also known as class-level variables.

- Since static variables and instance variables are both members of the class, they are often referred to as member variables.

- To create a static member variable, precede its declaration with the keyword static. When a member is declared static, it can be accessed before any object of the class is created and without reference to any object. 

- Syntax:
```
private static float deliveryCharge; //Declaration of static variable 
```

- Since the static variable gets created only once, now only one deliveryCharge member variable will be created and all the objects of that class will share that member variable. This can be visualized as

- How can we initialize the static variables?

- One way to initialize the static variable is to initialize at the time of declaration as shown below
```
private static float deliveryCharge = 1.5f; 
```
- This is fine if you have to directly initialize a value but this would not work if you need to perform some computation and then initialize the value of a static member variable. 

- In that case, Java provides one more type of static member called static block.

## Static Block

- Static blocks are used to initialize static variables when it cannot be done in a single line. They can also be used to add preprocessing if required.

- In the scenario of the delivery charge, the static variable deliveryCharge can be initialized with the help of static block as shown below
```
static {
    deliveryCharge = 1.5f; // initialize the static variable
    }
```

- Static blocks get executed only once when a class gets loaded in memory. If there are multiple static blocks, they will be executed in the order of their occurrence.

- After implementing static variable and static block, the Customer class looks as shown below.

```
class Customer {
	private String customerId;
	private String customerName;
	private long contactNumber;
	private String address;
	private static float deliveryCharge;
	static {
		deliveryCharge = 1.5f;
	}
	public Customer(String customerId, String customerName, long contactNumber,
			String address) {
		this.customerId = customerId;
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	public String getCustomerId() {
		return customerId;
	}
	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}
	public String getCustomerName() {
		return customerName;
	}
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	public long getContactNumber() {
		return contactNumber;
	}
	public void setContactNumber(long contactNumber) {
		this.contactNumber = contactNumber;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	public void displayCustomerDetails() {
		System.out.println("Displaying customer details \n***********");
		System.out.println("Customer Id : " + customerId);
		System.out.println("Customer Name : " + customerName);
		System.out.println("Contact Number : " + contactNumber);
		System.out.println("Address : " + address);
		System.out.println();
	}
	public double payBill(double totalPrice) {
		double discountPercentage = 5;
		System.out.println("Calculating final amount to be paid.....");
		double priceAfterDiscount = totalPrice * (1 - (discountPercentage / 100));
        double finalBillAmount=priceAfterDiscount + deliveryCharge;
		return finalBillAmount;
	}
}

```

## Static Method

- How can you access the static variable deliveryCharge in order to display the total bill amount which has to be paid by the customers?

- One way of accessing the static variable is with the help of instances of the class as shown below.

```
// Accessing the static variable with the help of instance of the class
System.out.println("Delivery Charge for customer1 is "+ customer1.deliveryCharge);
```
- Since the static variables are not specific to an object, accessing a static variable using an object is not the correct way.

- Instead, static variables should be accessed with the help of class name instead of the instance of the class as shown below:

```
// Accessing the static variable with the help of class
System.out.println("Delivery Charge for customer1 is "+ Customer.deliveryCharge);
```

- To update or retrieve the value of a static variable, you need to use the setter and getter methods.

- Since static variable is not specific to an object, you need a way to access the setter and getter methods without an object. This is possible by creating static methods.

- Static methods are methods prefixed with the static keyword. These methods can be accessed without an object of the class. Similar to static variables, they are accessed using the class name. A static method can be invoked without creating an instance of a class.

- A static method can only access static variables and cannot access instance variables.

- In case of the delivery charge scenario, you can create static setter and getter methods for deliveryCharge as shown below
```
public static float getDeliveryCharge() {
	return deliveryCharge;
}
public static void setDeliveryCharge(float deliveryCharge) {
	Customer.deliveryCharge = deliveryCharge;
}
```

- What happens if you try to access the deliveryCharge in setDeliveryCharge() method with the help of this?
```
public static void setDeliveryCharge(float deliveryCharge) {
	// Which object's deliveryCharge?
	this.deliveryCharge = deliveryCharge; // This line will throw error 
	}
```
- Static blocks and static methods cannot access non-static (instance) members directly since static methods do not belong to any object, so it is not possible to know which object's instance variables should be accessed. Trying to do so will result in a compilation error.

- However, non-static methods can access static members.

- The following code shows the implementation of Customer class with static variables, static blocks and static methods.

```
class Customer {
	private String customerId;
	private String customerName;
	private long contactNumber;
	private String address;
	private static float deliveryCharge;
	static {
		deliveryCharge = 1.5f;
	}
	public Customer(String customerId, String customerName, long contactNumber, String address) {
		this.customerId = customerId;
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	public String getCustomerId() {
		return customerId;
	}
	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}
	public String getCustomerName() {
		return customerName;
	}
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	public long getContactNumber() {
		return contactNumber;
	}
	public void setContactNumber(long contactNumber) {
		this.contactNumber = contactNumber;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	public static float getDeliveryCharge() {
		return deliveryCharge;
	}
	public static void setDeliveryCharge(float deliveryCharge) {
		Customer.deliveryCharge = deliveryCharge;
	}
	public void displayCustomerDetails() {
		System.out.println("Displaying customer details");
		System.out.println("Customer Id: " + this.customerId);
		System.out.println("Customer Name: " + this.customerName);
		System.out.println("Contact Number: " + this.contactNumber);
		System.out.println("Address: " + this.address);
		System.out.println("Delivery Charge: " + Customer.deliveryCharge);
		System.out.println();
	}
	public double payBill(double totalPrice) {
		double discountPercentage = 5;
		System.out.println("Calculating final amount to be paid.....");
		double priceAfterDiscount = totalPrice * (1 - (discountPercentage / 100));
		double finalBillAmount = priceAfterDiscount + Customer.deliveryCharge;
		return finalBillAmount;
	}
}
public class Tester {
	public static void main(String[] args) {
		Customer customer1 = new Customer("C1001", "Sam", 9945000009L, "Carolina Street, Springfield, 62702");
		Customer.setDeliveryCharge(2f);
		System.out.println("Final amount to be paid: $" + customer1.payBill(20));
		Customer customer2 = new Customer("C1002", "John", 9645000009L, "Carolina Street, Springfield, 62708");
		System.out.println("Final amount to be paid: $" + customer2.payBill(15));
		System.out.println("Delivery Charge for the customers are: " + Customer.getDeliveryCharge());
	}
}

```

- Another most common implementation of the static concept is in auto-generation of Ids.

Let us assume that we want to generate the customer Ids for all the customers. All the customer Ids must be unique and it should start with 'C101'. In order to implement this requirement and generate the customerId for all the customers, the concept of static is used as shown below.

```
class Customer {
	private static int counter; // Declaring the static variable counter
	private String customerId;
	private String customerName;
	private long contactNumber;
	private String address;
	private static float deliveryCharge;
	static {
		deliveryCharge = 1.5f;
		counter = 100; // Initializing the static variable counter
	}
	public Customer(String customerName, long contactNumber, String address) {
		// Incrementing the counter and initializing customerId
		this.customerId = "C" + ++Customer.counter;
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	// Static method to get the value of static variable counter
	public static int getCounter() {
		return counter;
	}
	// Static method to change the value of static variable counter if needed
	public static void setCounter(int counter) {
		Customer.counter = counter;
	}
	public String getCustomerId() {
		return customerId;
	}
	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}
	public String getCustomerName() {
		return customerName;
	}
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	public long getContactNumber() {
		return contactNumber;
	}
	public void setContactNumber(long contactNumber) {
		this.contactNumber = contactNumber;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	public static float getDeliveryCharge() {
		return deliveryCharge;
	}
	public static void setDeliveryCharge(float deliveryCharge) {
		Customer.deliveryCharge = deliveryCharge;
	}
	public void displayCustomerDetails() {
		System.out.println("Displaying customer details");
		System.out.println("Customer Id: " + this.customerId);
		System.out.println("Customer Name: " + this.customerName);
		System.out.println("Contact Number: " + this.contactNumber);
		System.out.println("Address: " + this.address);
		System.out.println("Delivery Charge: " + Customer.deliveryCharge);
		System.out.println();
	}
	public double payBill(double totalPrice) {
		double discountPercentage = 5;
		System.out.println("Calculating final amount to be paid.....");
		double priceAfterDiscount = totalPrice * (1 - (discountPercentage / 100));
		double finalBillAmount = priceAfterDiscount + Customer.deliveryCharge;
		return finalBillAmount;
	}
}
public class Tester {
	public static void main(String[] args) {
		Customer customer1 = new Customer("Sam", 9945000009L, "Carolina Street, Springfield, 62702");
		Customer customer2 = new Customer("John", 9645000009L, "Carolina Street, Springfield, 62708");
		Customer customer3 = new Customer("Alex", 9745000009L, "Carolina Street, Springfield, 62768");
		System.out.println("Customer Id for the first customer is: " + customer1.getCustomerId());
		System.out.println("Customer Id for the second customer is: " + customer2.getCustomerId());
		System.out.println("Customer Id for the third customer is: " + customer3.getCustomerId());
	}
}

```

## Static Tryout:
```
class Tester {
	public static void main(String[] args) {
		Car c1 = new Car("Red");
		Car c2 = new Car("Green");
		Car c3 = new Car("Blue");
		System.out.println("Number of cars created: " + Car.getNumberOfCars());
	}

	static {
		System.out.println("Tester class loaded");
	}
}

class Car {
	private String color;
	private static int numberOfCars = 0;

	static {
		System.out.println("Car class loaded");
	}

	public Car(String color) {
		this.color = color;
		Car.numberOfCars += 1;
	}

	public String getColor() {
		return this.color;
	}

	public static int getNumberOfCars() {
		return numberOfCars;
	}
}

```

# Association

- Association, also known as uses-a relationship exists between two classes when one object makes use of another object for its functionality. Here, both the objects can exist independently.


# Encapsulation

- Restrict certain parts of the code from directly accessing sensitive data.

# Inheritance

- Now, let us consider RegularCustomer and Guest classes. Since RegularCustomer and Guest are types of Customers, they must have access to the common attributes also. We can create a Customer class with the common attributes and methods and make these two classes inherit the attributes and behavior from Customer class.
- We can say that the RegularCustomer "is-A" Customer and Guest "is-A" Customer. When a class inherits from another class, then those classes are said to have inheritance relationship. The class which is inheriting is called the child/sub/derived class and the class which is getting inherited is called the parent/super/base class. Inheritance is also called as "is-A" relationship. Inheritance (is-a) is denoted by a line with an arrow head. 
- In case of an inheritance relationship, the attributes and behaviors get inherited just like a child inherits certain attributes and behaviors from his/her parent. 

- In terms of OOP, a child class inherits all the non-private attributes and methods.

- When we say a child class inherits the attributes and methods, we can treat the attributes and methods as if they are owned by the child class itself.

- In Java, a child class inherits the parent class using the "extends" keyword. Observe the below code.

```
class Customer {
	//Parent/Super/Base class
}
class RegularCustomer extends Customer {        // RegularCustomer is a Customer
	//Child/Sub/Derived class
}
class Guest extends Customer {                  // Guest is a Customer
	//Child/Sub/Derived class
}
```

# Constructor call inheritance

- By now, you have learnt that the derived classes inherit from the base class. You will now see how the child class object is created. As you all know, constructors are invoked while creating objects. When a child class object is created, the child class constructor invokes the parent class constructor before executing any statement present in the child constructor.

- Observe the below code and understand the sequence of constructor invocation.

```
class Customer {
	public Customer() {
		// 3: Parent constructor will be executed
		System.out.println("Creating a customer...");
		// 4: The flow will go back to the child constructor
	}
}
class RegularCustomer extends Customer {
	public RegularCustomer() {
		// 2: This constructor will then call the parent constructor
		System.out.println("It is a regular customer!");
		// 5: The flow will finally come here
	}
}
public class Tester {
	public static void main(String[] args) {
		RegularCustomer regularCustomer = new RegularCustomer();
		// 1: This line will be executed first and the flow will go to [2]
	}
}

```

# Need for super constructors
 
```
class Customer {

	private String customerId;
	private String customerName;

	public Customer(String customerId, String customerName) {
		this.customerId = customerId;
		this.customerName = customerName;
	}

	public Customer() {
		System.out.println("Parent parameterless constructor");
	}

	public String getCustomerId() {
		return customerId;
	}

	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public void displayCustomerDetails() {
		System.out.println("Displaying customer details \n***************************");
		System.out.println("Customer Id : " + this.customerId);
		System.out.println("Customer Name : " + this.customerName);
		System.out.println();
	}

}

class RegularCustomer extends Customer {

	private float discount;

	public RegularCustomer(String custId, String custName) {

		this.setCustomerId(custId);
		this.setCustomerName(custName);
		this.discount = 5.0f;
		System.out.println("Child parameterized constructor");
	}

	public float getDiscount() {
		return discount;
	}

	public void setDiscount(float discount) {
		this.discount = discount;
	}

}

class Tester {

	public static void main(String[] args) {

		RegularCustomer regularCustomer = new RegularCustomer("C1010", "Johns Kora");
		regularCustomer.displayCustomerDetails();

	}
}

```

- In the previous code snippet, the member variables were being set in the child class constructor and the parameterized constructor of parent class.

- Instead of setting the values of member variables in both the places, it would be better if the parameterized constructor of parent class is invoked from the child class constructor so that code can be reused. 

- By now, you know that the parent class parameterless constructor is implicitly invoked by the child class constructors but how are parameterized constructors of parent class invoked? 

- This can be done using super as shown in the code given below.

```
class Customer {
	private String customerId;
	private String customerName;
	public Customer(String customerId, String customerName) {
		this.customerId = customerId;
		this.customerName = customerName;
	}
	public void displayCustomerDetails() {
		System.out.println("Displaying customer details \n***************************");
		System.out.println("Customer Id : " + this.customerId);
		System.out.println("Customer Name : " + this.customerName);
	}
}
class RegularCustomer extends Customer {
	private float discount;
	public RegularCustomer(String custId, String custName) {
		super(custId, custName); // Invoking the parent class parameterized constructor
		this.discount = 5.0f;
	}
	public float getDiscount() {
		return discount;
	}
	public void setDiscount(float discount) {
		this.discount = discount;
	}
}
public class Tester {
	public static void main(String[] args) {
		RegularCustomer regularCustomer = new RegularCustomer("C1010", "Johns Kora");
		regularCustomer.displayCustomerDetails();
	}
}

```

- Please also note that the call to a super constructor has to be the first statement inside a constructor.

- In fact, the parameterless constructor of the parent class gets implicitly called by the child class constructors due to an implicit super() statement. This can also be done explicitly as shown below.

```
class RegularCustomer extends Customer {
	public RegularCustomer() {
		super(); // Invoking the parent class constructor
		System.out.println("It is a regular customer!");
	}
}

```

- Observe the code given below. The object of child class is getting created by passing parameters to the child class constructor but the variables get initialized using the parent class constructor.

```
class Employee {
	int employeeId;
	String employeeName;

	// Parameterized constructor
	Employee(int employeeId, String employeeName) {
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}

	public int getEmployeeId() {
		return employeeId;
	}

	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}

	public void display() {
		System.out.println("Employee details");
		System.out.println("Employee Id: " + employeeId);
		System.out.println("Employee Name: " + employeeName);
	}
}

class Manager extends Employee {
	private String designation;

	Manager(int employeeId, String employeeName, String designation) {
		super(employeeId, employeeName);
		this.designation = designation;
	}

	public String getDesignation() {
		return designation;
	}

	public void setDesignation(String designation) {
		this.designation = designation;
	}
}

class Tester {
	public static void main(String[] args) {
		Manager obj = new Manager(101, "John", "Lead");
		obj.display();
		System.out.println("Designation: " + obj.getDesignation());
	}
}
```

# Types of inheritances

- Single Inheritance : one class is extended by only one class. 
```
public class Customer {
	// Parent/Super/Base class
}
public class RegularCustomer extends Customer {        // RegularCustomer is a Customer
	// Child/Sub/Derived class
}
```

- Multilevel inheritance : In multilevel inheritance, a class extends another class which extends another class.


```
public class Customer {
    //code	
}
public class RegularCustomer extends Customer {     
     //code   
}
public class PremiumCustomer extends RegularCustomer {  
     //code  
   
}
```

- Hierarchical Inheritance : When more than one class extends the same base class, then that type of inheritance is said to be Hierarchical Inheritance.

```
public class Customer {
	// code here
}
public class RegularCustomer extends Customer {
	// code here
}
public class Guest extends Customer {
	// code here
}
```

- Multiple Inheritance : In Multiple Inheritance, one class extends multiple classes. Please note that Multiple Inheritance is NOT supported in many object oriented programming languages including Java.

# The main advantages of inheritance are:

- Code reusability - The codes are defined only once and can be used multiple times. We define the functionalities in the parent class and any number of child classes can use the functionalities at any time.

- Saves time and effort due to reusability of code.

- Inheritance makes the application code more flexible to changes

- Inheritance results in better organization of codes into smaller and simpler compilation units which makes the code more readable and easy to debug


# Packages

- Just as books are cataloged and arranged in a library, it is important for us to organize our Java files. In order to follow a modular approach, a set of related classes and interfaces can be grouped together at one place called package.

- Packages help in organizing our Java files. It is a mechanism of grouping similar types of classes and interfaces collectively based on functionality.

## Adv:

Creating packages and grouping related documents together mainly have the following advantages:

Modularization: Real-life Java projects will have several hundreds of classes and other files. Using packages provides a good structure for projects. It becomes easier to locate the related classes which improve efficiency.

Re-usability: It provides re-usability. If a particular functionality of class has to be accessed in a different class of different package, then, you can just import the class into different packages and use it.

Name Conflicts: If there is a need for creating another class with the same name, then we can define two classes with the same name in different packages to avoid name collision.

Controlled Access: It provides access protection. Protected and default have package level access control. A protected member is accessible by classes in the same package and its sub-classes of the same or another package. A default member (without any access specifier) is accessible by classes in the same package only.

Data Encapsulation: They provide a way to hide classes, preventing other programs from accessing classes that are meant for internal use only.

Therefore, it is a good practice to use packages.

Packages can be divided into two categories:

1. Built-in Packages

2. User-Defined Packages

- Built-in Packages: Built-in packages or predefined packages are those that come along as a part of JDK (Java Development Kit). They consist of a huge number of predefined classes and interfaces that are part of Java API. Some of the commonly used built-in packages are java.lang, java.io, java.util, etc.

- User-Defined Packages: User-defined packages are those which are developed by users in order to group related classes, interfaces and sub-packages.

- A package in Java can be created either with the help of IDE or by using the package keyword as the first line of a Java file to specify the package of a class. There can be only one package statement in each source file and it applies to all classes or interfaces in the file.

- If a package statement is not used, then the Java files will be placed in the current default package.

- The naming convention for packages is to write the complete package in lowercase.

- Only public classes can be imported into different packages.

# Protected

- Variables, methods and constructors which are declared protected in the parent class can be accessed only by the sub classes in other packages or any class within the same package.

- The protected access modifier cannot be applied to classes and interfaces.

- Protected access modifier allows the child classes present in different packages to use the protected method or variable of the parent class while preventing other classes of the different package from doing so.

- Next, you would see how to access classes and files of one package in another package.

# Import

- import keyword is used to import built-in or user-defined packages into a Java source file so that a class can refer to another class that is in a different package.

- There are three ways to access the Java source file of one package in another package.

1. To import all the classes from a particular package:
```
import packagename.*;
```
If you use packagename.*, then all the classes and interfaces of the package will be accessible but the classes and interfaces present inside the sub packages will not be available for use.

2. To import only the class/classes you want to use:
```
import  packagename.classname;
```
If you import packagename.classname, then only the class with the name classname of the package with the name packagename will be available for use

3. Using a fully qualified name:
```
packagename.classname;
```
If you use a fully qualified name to import any class into your program, then only that particular class of the package will be accessible in your program, other classes in the same package will not be accessible. For this approach, there is no need to use the import statement but you will have to use the fully qualified name every time you are accessing the class or the interface. This is not a recommended approach.

# The table given below explains the accessibility of the different access modifiers.

										Private		Default 	Protected 	Public
Same class								YES			YES			YES			YES
Sub classess within the same package    NO 			YES 		YES			YES
Same package							NO			YES 		YES			YES
Sub classes in diffrent packages		NO 			NO			YES			YES
Different Packages						NO			NO			NO  		YES

To summarize:

Anything declared as public can be accessed from anywhere

Anything declared as private can be accessed only within that class

If access modifier is not mentioned, an element is accessible to all the classes in the same package

Anything declared as protected can be accessible to all the classes inside the same package and to the sub classes present in a different package

# Package Summary

- Packages help in organizing Java files by grouping similar Java files together.

- Every class is part of some package.

- When a package name is not specified, the classes are placed inside the default package.

- A class can have only one package statement but it can have more than one import package statements.

- The name of the package must be the same as the directory under which the file is saved.

- When importing another package, package declaration must be the first statement followed by package import.

# Linkedin List

- Java Collections framework also provides LinkedList class which removes the need of creating your own class for implementing a linked list. 

- LinkedList class implements the List interface as shown below.

- A linked list can be created as shown below.

```
List<String> myList = new LinkedList<String>();
//or
LinkedList<String> myList = new LinkedList<String>();
```

- Methods:
1. void add(int index, E element) - insert an elemnet at a spcified position
2. bool add(E element) - insert at the end
3. clear() - remove all elements
4. bool contains(obj o) - return true if list contains the specified obj
5. E get(int index) - return the element at a specified index
6. int indexOf(object o) - return the index of the first occurance of the specified obj else return -1 if LL is empty
7. bool remove(object o) - remove the 1 occurance
8. E set(int index, E element) - replace the elemst
9. Object[] toArray() - return an array conatining all the elements in the list
10. int size() - returns number of element

- Methods in LinkedList - Tryout

```
import java.util.List;
import java.util.LinkedList;

class EuropeTrip {

	public static void main(String args[]) {
		// Creating a LinkedList
		List<String> cities = new LinkedList<String>();

		// Adding elements
		cities.add("Milan");
		cities.add("Venice");
		cities.add("Munich");
		cities.add("Vienna");

		// Displaying elements
		System.out.println(cities);

		// Inserting elements
		cities.add(3, "Prague");
		System.out.println(cities);

		// Removing elements
		cities.remove("Munich");
		System.out.println(cities);

		// Replacing element
		cities.set(2, "Berlin");
		System.out.println(cities);

		// Displaying size
		System.out.println(cities.size());

		// Checking if an element is present
		System.out.println(cities.contains("Paris"));

		// Getting element at specific position
		System.out.println(cities.get(0));

		// Clearing the elements from the LinkedList
		cities.clear();
		System.out.println(cities);

		// Try to test the other methods of the LinkedList class
	}
}
```

# Queue Interface

- Queue is a collection used to hold multiple elements prior to processing.

- It is an interface available in java.util package and extends java.util.Collection interface.
Just like List, Queue is a collection of ordered elements (or objects) but it performs insertion and removal operations differently.

1. Queue represents an ordered list of elements

2. Queue supports all methods of Collection interface

3. All queues support insertion at the tail of the queue and removal from the head of the queue, except Deque

4. Deques are queues but they support element insertion and removal at both ends

- Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are 

1. Priority queues, which order elements according to a supplied comparator, or the elements' natural ordering

2. LIFO queues (or stacks) which order the elements according to LIFO (last-in-first-out)

- Queue implementations generally do not allow insertion of null elements, although some of them do not prohibit insertion of null. It is advisable not to insert null into a Queue as null is returned by the poll method when the queue contains no elements.

- Queue supports all operations supported by Collection interface and also provides additional insertion and extraction operations.

- Each of these operations exists in two forms.

1. One set of operations throw an exception if the operation fails

2. The other set of operations return a special value (either null or false) if the operation fails

Operations			Throw Exception 	Returning Special Value

Insert				add 				offer
Remove 				remove				poll
Examine				element				peek

QUEUE INTERFACE

1. Particular orderd is maintained
2. Typically FIFO orders
3. Add elements from front of queue

METHODS
1. For addinng elemnts:
boolean add(obj) - exception when size is full
boolean offer(obj) - no exception but return false

2. For removing 
E remove - exception when size is empty - NOSUCHELEMENT
E poll - No exception but return null

3. For accessing front most element
E element() - Exception when q is empty
E peek() - No exception but returns null

push()
pop()

# Deque Interface

Deque is a linear collection that supports element insertion and removal at both ends. This interface extends the Queue interface.

The name deque is short for "double ended queue" and is usually pronounced "deck".

It supports capacity restricted deques as well as those with no fixed size limit.

Deque can be instantiated as:
```
Deque<String> deque = new ArrayDeque<>();

```

ArrayDeque class is the implementation of the Deque interface.

Unlike queue, you can add or delete the elements from both the ends through ArrayDeque.

Using this ArrayDeque class, both queue and stack can be implemented.

You will now see the implementation of queue and stack using ArrayDeque class.

# Queue using ArrayDeque:
```
import java.util.Deque;
import java.util.ArrayDeque;

class Tester{

	public static void main(String[] args) {

		Deque<String> queue = new ArrayDeque<String>();	// no restrictions in capacity
		queue.add("Joe");
		queue.add("Jack");
		queue.add("Eva");
		queue.add("Mia");
		queue.add("Luke");

		System.out.println("People in queue - After addition of 5 people");
		for (String str : queue) {
			System.out.println(str);
		}
		
		queue.remove();
		queue.remove();
		queue.remove();
		
		System.out.println("\nPeople in queue - After removal of 3 people");
		for (String str : queue) {
			System.out.println(str);
		}
		
		System.out.println();
		System.out.println("Head of the queue using element() - "+queue.element());
		System.out.println("Head of the queue using peek() - "+queue.peek());
		queue.remove();
		queue.remove();
		
		// new person added to the empty queue using offer()
		queue.offer("Emma");
		
		// newly added person removed using poll()
		queue.poll();
		
		System.out.println();
		System.out.println("Removing the head of the queue using poll when queue is empty - "+queue.poll());	// returns null since queue is empty		
		
		System.out.println("Head of the queue using peek() when queue is empty - "+queue.peek());	// returns null since queue is empty
		
	    /* Uncomment the lines of code given below one at a time and observe the output */
        //System.out.println("Head of the queue using element() when queue is empty - "+queue.element());	// throws NoSuchElementException since queue is empty
		
        //System.out.println("Removing the head of the queue using remove() when queue is empty");
        //queue.remove();		// throws NoSuchElementException since queue is empty

	}
}
```

Stack using ArrayDeque

```
import java.util.Deque;
import java.util.ArrayDeque;

class Tester {

	public static void main(String[] args) {

		Deque<Integer> stack = new ArrayDeque<Integer>();	// no restrictions in capacity
		stack.push(1);
		stack.push(2);
		stack.push(3);
		stack.push(4);
		stack.push(5);

		System.out.println("Numbers in stack - After addition of 5 values");
		for (Integer val : stack) {
			System.out.println(val);
		}
		
		stack.pop();
		stack.pop();
		stack.pop();
		
		System.out.println("\nNumbers in stack - After removal of 3 values");
		for (Integer val : stack) {
			System.out.println(val);
		}
		
		System.out.println();
		System.out.println("Top of the stack using peek() - "+stack.peek());
		
		stack.pop();
		stack.pop();
		
		//Uncomment the below code and observe the output
        //System.out.println("Trying to remove the element from the top of the stack using pop() when stack is empty - "+stack.pop());	// throws NoSuchElementException since stack is empty		
	
	}
}
```

