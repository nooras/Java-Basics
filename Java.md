# Programming
- Def1 : A set of instructions is known as a program and the act of creating a program is known as programming Programs are created to solve the problems, to automate the processes and to reduce repetitive and/or manual work.
- Def2 : A program is a collection of instructions that performs a specific task when executed by a computer.

# Algorithm 
- Set of steps

# Java 
- High-level programming languages

# Compiler and interpreter 
- Which converts code into binary language. Computer Cannot understand high level language, they understand only binary language i.e. 0 and 1. Conversion is possible uisng system software called compilers and interpreters. In Java, the program (source code) written by the programmer gets compiled and converted into byte code (compiled code) by the Java compiler. 
- All the byte codes required for the program are then given to the interpreter. The interpreter reads the byte code line by line, converts it to binary form, also called as machine language or binary language, and then executes it.
- This process requires some support and an environment for the execution to happen. JDK (Java Development Kit) helps in this for execution of a Java program. It provides library support and Java Runtime Environment (JRE), the environment for developing and executing Java based applications and programs.

# Hello world program in java
```
class Welcome {
	public static void main(String[] args) {
		System.out.println("Hello World! Welcome to Java Programming!");
	}
}
```

The program displays a message - 'Hello World! Welcome to Java Programming!'. Here are some of the syntax rules of Java language:

- The message is displayed using System.out.println which is used for displaying messages or output in Java.

- Every statement in Java program must end with semicolon (;).

- Every statement in Java must be present inside a method. A method is a block of code that performs a particular task.

- In the code given above, the method is named as main. Every program in Java must have a main method as the code execution starts from the main method.  

- The method is defined using curly braces ({}). { signifies the start of a code block and } signifies its end.

- Every method in Java must be present inside a class. In the code given above, the class is named as Welcome. You will learn about classes and methods in detail later in the course.

- Java is a case-sensitive programming language. E.g. - The word class should be written in lower case.

# JDK

The development, compilation and execution of Java programs is taken care by JDK which contains 2 main components: Development tools and JRE.

The development tools consist of Java compiler and Java launcher.

- Java compiler (javac.exe) - It is the primary Java compiler. The compiler accepts Java source code and produces Java bytecode conforming to the Java Virtual Machine Specification (JVMS).

- Java launcher (java.exe) - It helps in launching a Java application during execution.

Next, let us discuss about Java Runtime Environment (JRE).

The Java Runtime Environment (JRE) contains Java Virtual Machine(JVM) and the Java standard library (Java Class Library).

- Java Virtual Machine (JVM) - It is the virtual machine that enables the computer to run Java programs.

- Java standard library (Java Class Library) - It is a set of dynamically loadable libraries that Java applications can call at run time. Java Platform is not dependent on a specific operating system and hence applications cannot rely on any of the platform-native libraries. So, the Java Platform provides a set of standard class libraries containing functions common to modern operating systems.

how does a Java program get executed by the computer.

- The Java source code is saved in a file with .java extension. When we compile a Java program (.java file), .class files (byte code) with the same class names present in .java file are generated by the Java compiler (javac). These .class files go through various steps when we run the program as shown in the below diagram.

## Platform Indepent

If a program written on a particular platform can run on other platforms without any recompilation, it is known as a platform independent program.

Usually larger applications are created by a team of developers. While most of them could be working on the same operating system such as Windows, others might be using different operating systems like Mac or Linux. In this scenario, we might have a situation where a program written on Windows needs to be executed on Mac OS also. 

Since Java is platform independent, it is not a problem. A program written using Java on Windows will execute without any recompilation on any other platform.

## Features
- Simple
- Robust
- Architecchural Neutral
- Secure
- Mutlti threaded

# Program
```
class Tester {
	public static void main(String[] args) {
		// Implement your code here 
		int principal = 5000, rate = 10, time = 5;
		System.out.println((principal*rate*time)/100)
		
	}
}
```

Implement a program to find and display the maximum number out of the given three numbers

```
class Tester {
	public static void main(String[] args) {
		// Implement your code here 
		int num1 = 3, num2 = 4, num3 = 1;
		if ((num1 > num2) && (num1 > num3)){
		    System.out.println(num1);
		}else if((num2 > num1) && (num2 > num3)){
		    System.out.println(num2);
		}else{
		    System.out.println(num3);
		}
	}
}

```

# OOP

- Object Oriented Programming(OOP) is a type of programming approach which enables the programmers to work with real life entities like Customer, Trainee, Employee, Company, Product, Food, Book, etc.

- Java, C#, Simula, JavaScript, Python, C++, Visual Basic .NET, Ruby, Scala, PHP etc. are some of the popular object-oriented programming languages.

- OOP helps a programmer in breaking down the code into smaller modules. These modules (classes) will have state(represented by attributes/variables) and functionality (represented by behavior/methods).

- These modules can then be used for representing the individual real life entities known as objects.

- E.g. - We can have a class named Customer to represent the state and behavior of all customers. Each individual customer can then be represented using an object of the Customer class.


# Encapsulation

- Restrict certain parts of the code from directly accessing sensitive data.

# Inheritance

- Now, let us consider RegularCustomer and Guest classes. Since RegularCustomer and Guest are types of Customers, they must have access to the common attributes also. We can create a Customer class with the common attributes and methods and make these two classes inherit the attributes and behavior from Customer class.
- We can say that the RegularCustomer "is-A" Customer and Guest "is-A" Customer. When a class inherits from another class, then those classes are said to have inheritance relationship. The class which is inheriting is called the child/sub/derived class and the class which is getting inherited is called the parent/super/base class. Inheritance is also called as "is-A" relationship. Inheritance (is-a) is denoted by a line with an arrow head. 
- In case of an inheritance relationship, the attributes and behaviors get inherited just like a child inherits certain attributes and behaviors from his/her parent. 

- In terms of OOP, a child class inherits all the non-private attributes and methods.

- When we say a child class inherits the attributes and methods, we can treat the attributes and methods as if they are owned by the child class itself.

- In Java, a child class inherits the parent class using the "extends" keyword. Observe the below code.

```
class Customer {
	//Parent/Super/Base class
}
class RegularCustomer extends Customer {        // RegularCustomer is a Customer
	//Child/Sub/Derived class
}
class Guest extends Customer {                  // Guest is a Customer
	//Child/Sub/Derived class
}
```

# Constructor call inheritance

- By now, you have learnt that the derived classes inherit from the base class. You will now see how the child class object is created. As you all know, constructors are invoked while creating objects. When a child class object is created, the child class constructor invokes the parent class constructor before executing any statement present in the child constructor.

- Observe the below code and understand the sequence of constructor invocation.

```
class Customer {
	public Customer() {
		// 3: Parent constructor will be executed
		System.out.println("Creating a customer...");
		// 4: The flow will go back to the child constructor
	}
}
class RegularCustomer extends Customer {
	public RegularCustomer() {
		// 2: This constructor will then call the parent constructor
		System.out.println("It is a regular customer!");
		// 5: The flow will finally come here
	}
}
public class Tester {
	public static void main(String[] args) {
		RegularCustomer regularCustomer = new RegularCustomer();
		// 1: This line will be executed first and the flow will go to [2]
	}
}

```

# Need for super constructors
 
```
class Customer {

	private String customerId;
	private String customerName;

	public Customer(String customerId, String customerName) {
		this.customerId = customerId;
		this.customerName = customerName;
	}

	public Customer() {
		System.out.println("Parent parameterless constructor");
	}

	public String getCustomerId() {
		return customerId;
	}

	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public void displayCustomerDetails() {
		System.out.println("Displaying customer details \n***************************");
		System.out.println("Customer Id : " + this.customerId);
		System.out.println("Customer Name : " + this.customerName);
		System.out.println();
	}

}

class RegularCustomer extends Customer {

	private float discount;

	public RegularCustomer(String custId, String custName) {

		this.setCustomerId(custId);
		this.setCustomerName(custName);
		this.discount = 5.0f;
		System.out.println("Child parameterized constructor");
	}

	public float getDiscount() {
		return discount;
	}

	public void setDiscount(float discount) {
		this.discount = discount;
	}

}

class Tester {

	public static void main(String[] args) {

		RegularCustomer regularCustomer = new RegularCustomer("C1010", "Johns Kora");
		regularCustomer.displayCustomerDetails();

	}
}

```

- In the previous code snippet, the member variables were being set in the child class constructor and the parameterized constructor of parent class.

- Instead of setting the values of member variables in both the places, it would be better if the parameterized constructor of parent class is invoked from the child class constructor so that code can be reused. 

- By now, you know that the parent class parameterless constructor is implicitly invoked by the child class constructors but how are parameterized constructors of parent class invoked? 

- This can be done using super as shown in the code given below.

```
class Customer {
	private String customerId;
	private String customerName;
	public Customer(String customerId, String customerName) {
		this.customerId = customerId;
		this.customerName = customerName;
	}
	public void displayCustomerDetails() {
		System.out.println("Displaying customer details \n***************************");
		System.out.println("Customer Id : " + this.customerId);
		System.out.println("Customer Name : " + this.customerName);
	}
}
class RegularCustomer extends Customer {
	private float discount;
	public RegularCustomer(String custId, String custName) {
		super(custId, custName); // Invoking the parent class parameterized constructor
		this.discount = 5.0f;
	}
	public float getDiscount() {
		return discount;
	}
	public void setDiscount(float discount) {
		this.discount = discount;
	}
}
public class Tester {
	public static void main(String[] args) {
		RegularCustomer regularCustomer = new RegularCustomer("C1010", "Johns Kora");
		regularCustomer.displayCustomerDetails();
	}
}

```

- Please also note that the call to a super constructor has to be the first statement inside a constructor.

- In fact, the parameterless constructor of the parent class gets implicitly called by the child class constructors due to an implicit super() statement. This can also be done explicitly as shown below.

```
class RegularCustomer extends Customer {
	public RegularCustomer() {
		super(); // Invoking the parent class constructor
		System.out.println("It is a regular customer!");
	}
}

```

- Observe the code given below. The object of child class is getting created by passing parameters to the child class constructor but the variables get initialized using the parent class constructor.

```
class Employee {
	int employeeId;
	String employeeName;

	// Parameterized constructor
	Employee(int employeeId, String employeeName) {
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}

	public int getEmployeeId() {
		return employeeId;
	}

	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}

	public void display() {
		System.out.println("Employee details");
		System.out.println("Employee Id: " + employeeId);
		System.out.println("Employee Name: " + employeeName);
	}
}

class Manager extends Employee {
	private String designation;

	Manager(int employeeId, String employeeName, String designation) {
		super(employeeId, employeeName);
		this.designation = designation;
	}

	public String getDesignation() {
		return designation;
	}

	public void setDesignation(String designation) {
		this.designation = designation;
	}
}

class Tester {
	public static void main(String[] args) {
		Manager obj = new Manager(101, "John", "Lead");
		obj.display();
		System.out.println("Designation: " + obj.getDesignation());
	}
}
```

# Types of inheritances

- Single Inheritance : one class is extended by only one class. 
```
public class Customer {
	// Parent/Super/Base class
}
public class RegularCustomer extends Customer {        // RegularCustomer is a Customer
	// Child/Sub/Derived class
}
```

- Multilevel inheritance : In multilevel inheritance, a class extends another class which extends another class.


```
public class Customer {
    //code	
}
public class RegularCustomer extends Customer {     
     //code   
}
public class PremiumCustomer extends RegularCustomer {  
     //code  
   
}
```

- Hierarchical Inheritance : When more than one class extends the same base class, then that type of inheritance is said to be Hierarchical Inheritance.

```
public class Customer {
	// code here
}
public class RegularCustomer extends Customer {
	// code here
}
public class Guest extends Customer {
	// code here
}
```

- Multiple Inheritance : In Multiple Inheritance, one class extends multiple classes. Please note that Multiple Inheritance is NOT supported in many object oriented programming languages including Java.

# The main advantages of inheritance are:

- Code reusability - The codes are defined only once and can be used multiple times. We define the functionalities in the parent class and any number of child classes can use the functionalities at any time.

- Saves time and effort due to reusability of code.

- Inheritance makes the application code more flexible to changes

- Inheritance results in better organization of codes into smaller and simpler compilation units which makes the code more readable and easy to debug


# Packages

- Just as books are cataloged and arranged in a library, it is important for us to organize our Java files. In order to follow a modular approach, a set of related classes and interfaces can be grouped together at one place called package.

- Packages help in organizing our Java files. It is a mechanism of grouping similar types of classes and interfaces collectively based on functionality.

## Adv:

Creating packages and grouping related documents together mainly have the following advantages:

Modularization: Real-life Java projects will have several hundreds of classes and other files. Using packages provides a good structure for projects. It becomes easier to locate the related classes which improve efficiency.

Re-usability: It provides re-usability. If a particular functionality of class has to be accessed in a different class of different package, then, you can just import the class into different packages and use it.

Name Conflicts: If there is a need for creating another class with the same name, then we can define two classes with the same name in different packages to avoid name collision.

Controlled Access: It provides access protection. Protected and default have package level access control. A protected member is accessible by classes in the same package and its sub-classes of the same or another package. A default member (without any access specifier) is accessible by classes in the same package only.

Data Encapsulation: They provide a way to hide classes, preventing other programs from accessing classes that are meant for internal use only.

Therefore, it is a good practice to use packages.

Packages can be divided into two categories:

1. Built-in Packages

2. User-Defined Packages

- Built-in Packages: Built-in packages or predefined packages are those that come along as a part of JDK (Java Development Kit). They consist of a huge number of predefined classes and interfaces that are part of Java API. Some of the commonly used built-in packages are java.lang, java.io, java.util, etc.

- User-Defined Packages: User-defined packages are those which are developed by users in order to group related classes, interfaces and sub-packages.

- A package in Java can be created either with the help of IDE or by using the package keyword as the first line of a Java file to specify the package of a class. There can be only one package statement in each source file and it applies to all classes or interfaces in the file.

- If a package statement is not used, then the Java files will be placed in the current default package.

- The naming convention for packages is to write the complete package in lowercase.

- Only public classes can be imported into different packages.

# Protected

- Variables, methods and constructors which are declared protected in the parent class can be accessed only by the sub classes in other packages or any class within the same package.

- The protected access modifier cannot be applied to classes and interfaces.

- Protected access modifier allows the child classes present in different packages to use the protected method or variable of the parent class while preventing other classes of the different package from doing so.

- Next, you would see how to access classes and files of one package in another package.

# Import

- import keyword is used to import built-in or user-defined packages into a Java source file so that a class can refer to another class that is in a different package.

- There are three ways to access the Java source file of one package in another package.

1. To import all the classes from a particular package:
```
import packagename.*;
```
If you use packagename.*, then all the classes and interfaces of the package will be accessible but the classes and interfaces present inside the sub packages will not be available for use.

2. To import only the class/classes you want to use:
```
import  packagename.classname;
```
If you import packagename.classname, then only the class with the name classname of the package with the name packagename will be available for use

3. Using a fully qualified name:
```
packagename.classname;
```
If you use a fully qualified name to import any class into your program, then only that particular class of the package will be accessible in your program, other classes in the same package will not be accessible. For this approach, there is no need to use the import statement but you will have to use the fully qualified name every time you are accessing the class or the interface. This is not a recommended approach.

# The table given below explains the accessibility of the different access modifiers.

										Private		Default 	Protected 	Public
Same class								YES			YES			YES			YES
Sub classess within the same package    NO 			YES 		YES			YES
Same package							NO			YES 		YES			YES
Sub classes in diffrent packages		NO 			NO			YES			YES
Different Packages						NO			NO			NO  		YES

To summarize:

Anything declared as public can be accessed from anywhere

Anything declared as private can be accessed only within that class

If access modifier is not mentioned, an element is accessible to all the classes in the same package

Anything declared as protected can be accessible to all the classes inside the same package and to the sub classes present in a different package

# Package Summary

- Packages help in organizing Java files by grouping similar Java files together.

- Every class is part of some package.

- When a package name is not specified, the classes are placed inside the default package.

- A class can have only one package statement but it can have more than one import package statements.

- The name of the package must be the same as the directory under which the file is saved.

- When importing another package, package declaration must be the first statement followed by package import.

# Linkedin List

- Java Collections framework also provides LinkedList class which removes the need of creating your own class for implementing a linked list. 

- LinkedList class implements the List interface as shown below.

- A linked list can be created as shown below.

```
List<String> myList = new LinkedList<String>();
//or
LinkedList<String> myList = new LinkedList<String>();
```

- Methods:
1. void add(int index, E element) - insert an elemnet at a spcified position
2. bool add(E element) - insert at the end
3. clear() - remove all elements
4. bool contains(obj o) - return true if list contains the specified obj
5. E get(int index) - return the element at a specified index
6. int indexOf(object o) - return the index of the first occurance of the specified obj else return -1 if LL is empty
7. bool remove(object o) - remove the 1 occurance
8. E set(int index, E element) - replace the elemst
9. Object[] toArray() - return an array conatining all the elements in the list
10. int size() - returns number of element

- Methods in LinkedList - Tryout

```
import java.util.List;
import java.util.LinkedList;

class EuropeTrip {

	public static void main(String args[]) {
		// Creating a LinkedList
		List<String> cities = new LinkedList<String>();

		// Adding elements
		cities.add("Milan");
		cities.add("Venice");
		cities.add("Munich");
		cities.add("Vienna");

		// Displaying elements
		System.out.println(cities);

		// Inserting elements
		cities.add(3, "Prague");
		System.out.println(cities);

		// Removing elements
		cities.remove("Munich");
		System.out.println(cities);

		// Replacing element
		cities.set(2, "Berlin");
		System.out.println(cities);

		// Displaying size
		System.out.println(cities.size());

		// Checking if an element is present
		System.out.println(cities.contains("Paris"));

		// Getting element at specific position
		System.out.println(cities.get(0));

		// Clearing the elements from the LinkedList
		cities.clear();
		System.out.println(cities);

		// Try to test the other methods of the LinkedList class
	}
}
```

# Queue Interface

- Queue is a collection used to hold multiple elements prior to processing.

- It is an interface available in java.util package and extends java.util.Collection interface.
Just like List, Queue is a collection of ordered elements (or objects) but it performs insertion and removal operations differently.

1. Queue represents an ordered list of elements

2. Queue supports all methods of Collection interface

3. All queues support insertion at the tail of the queue and removal from the head of the queue, except Deque

4. Deques are queues but they support element insertion and removal at both ends

- Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are 

1. Priority queues, which order elements according to a supplied comparator, or the elements' natural ordering

2. LIFO queues (or stacks) which order the elements according to LIFO (last-in-first-out)

- Queue implementations generally do not allow insertion of null elements, although some of them do not prohibit insertion of null. It is advisable not to insert null into a Queue as null is returned by the poll method when the queue contains no elements.

- Queue supports all operations supported by Collection interface and also provides additional insertion and extraction operations.

- Each of these operations exists in two forms.

1. One set of operations throw an exception if the operation fails

2. The other set of operations return a special value (either null or false) if the operation fails

Operations			Throw Exception 	Returning Special Value

Insert				add 				offer
Remove 				remove				poll
Examine				element				peek

QUEUE INTERFACE

1. Particular orderd is maintained
2. Typically FIFO orders
3. Add elements from front of queue

METHODS
1. For addinng elemnts:
boolean add(obj) - exception when size is full
boolean offer(obj) - no exception but return false

2. For removing 
E remove - exception when size is empty - NOSUCHELEMENT
E poll - No exception but return null

3. For accessing front most element
E element() - Exception when q is empty
E peek() - No exception but returns null

push()
pop()

# Deque Interface

Deque is a linear collection that supports element insertion and removal at both ends. This interface extends the Queue interface.

The name deque is short for "double ended queue" and is usually pronounced "deck".

It supports capacity restricted deques as well as those with no fixed size limit.

Deque can be instantiated as:
```
Deque<String> deque = new ArrayDeque<>();

```

ArrayDeque class is the implementation of the Deque interface.

Unlike queue, you can add or delete the elements from both the ends through ArrayDeque.

Using this ArrayDeque class, both queue and stack can be implemented.

You will now see the implementation of queue and stack using ArrayDeque class.

# Queue using ArrayDeque:
```
import java.util.Deque;
import java.util.ArrayDeque;

class Tester{

	public static void main(String[] args) {

		Deque<String> queue = new ArrayDeque<String>();	// no restrictions in capacity
		queue.add("Joe");
		queue.add("Jack");
		queue.add("Eva");
		queue.add("Mia");
		queue.add("Luke");

		System.out.println("People in queue - After addition of 5 people");
		for (String str : queue) {
			System.out.println(str);
		}
		
		queue.remove();
		queue.remove();
		queue.remove();
		
		System.out.println("\nPeople in queue - After removal of 3 people");
		for (String str : queue) {
			System.out.println(str);
		}
		
		System.out.println();
		System.out.println("Head of the queue using element() - "+queue.element());
		System.out.println("Head of the queue using peek() - "+queue.peek());
		queue.remove();
		queue.remove();
		
		// new person added to the empty queue using offer()
		queue.offer("Emma");
		
		// newly added person removed using poll()
		queue.poll();
		
		System.out.println();
		System.out.println("Removing the head of the queue using poll when queue is empty - "+queue.poll());	// returns null since queue is empty		
		
		System.out.println("Head of the queue using peek() when queue is empty - "+queue.peek());	// returns null since queue is empty
		
	    /* Uncomment the lines of code given below one at a time and observe the output */
        //System.out.println("Head of the queue using element() when queue is empty - "+queue.element());	// throws NoSuchElementException since queue is empty
		
        //System.out.println("Removing the head of the queue using remove() when queue is empty");
        //queue.remove();		// throws NoSuchElementException since queue is empty

	}
}
```

Stack using ArrayDeque

```
import java.util.Deque;
import java.util.ArrayDeque;

class Tester {

	public static void main(String[] args) {

		Deque<Integer> stack = new ArrayDeque<Integer>();	// no restrictions in capacity
		stack.push(1);
		stack.push(2);
		stack.push(3);
		stack.push(4);
		stack.push(5);

		System.out.println("Numbers in stack - After addition of 5 values");
		for (Integer val : stack) {
			System.out.println(val);
		}
		
		stack.pop();
		stack.pop();
		stack.pop();
		
		System.out.println("\nNumbers in stack - After removal of 3 values");
		for (Integer val : stack) {
			System.out.println(val);
		}
		
		System.out.println();
		System.out.println("Top of the stack using peek() - "+stack.peek());
		
		stack.pop();
		stack.pop();
		
		//Uncomment the below code and observe the output
        //System.out.println("Trying to remove the element from the top of the stack using pop() when stack is empty - "+stack.pop());	// throws NoSuchElementException since stack is empty		
	
	}
}
```

