# Programming
- Def1 : A set of instructions is known as a program and the act of creating a program is known as programming Programs are created to solve the problems, to automate the processes and to reduce repetitive and/or manual work.
- Def2 : A program is a collection of instructions that performs a specific task when executed by a computer.

# Algorithm 
- Set of steps

# Java 
- High-level programming languages

# Compiler and interpreter 
- Which converts code into binary language. Computer Cannot understand high level language, they understand only binary language i.e. 0 and 1. Conversion is possible uisng system software called compilers and interpreters. In Java, the program (source code) written by the programmer gets compiled and converted into byte code (compiled code) by the Java compiler. 
- All the byte codes required for the program are then given to the interpreter. The interpreter reads the byte code line by line, converts it to binary form, also called as machine language or binary language, and then executes it.
- This process requires some support and an environment for the execution to happen. JDK (Java Development Kit) helps in this for execution of a Java program. It provides library support and Java Runtime Environment (JRE), the environment for developing and executing Java based applications and programs.

# Hello world program in java
```
class Welcome {
	public static void main(String[] args) {
		System.out.println("Hello World! Welcome to Java Programming!");
	}
}
```

The program displays a message - 'Hello World! Welcome to Java Programming!'. Here are some of the syntax rules of Java language:

- The message is displayed using System.out.println which is used for displaying messages or output in Java.

- Every statement in Java program must end with semicolon (;).

- Every statement in Java must be present inside a method. A method is a block of code that performs a particular task.

- In the code given above, the method is named as main. Every program in Java must have a main method as the code execution starts from the main method.  

- The method is defined using curly braces ({}). { signifies the start of a code block and } signifies its end.

- Every method in Java must be present inside a class. In the code given above, the class is named as Welcome. You will learn about classes and methods in detail later in the course.

- Java is a case-sensitive programming language. E.g. - The word class should be written in lower case.

# JDK

The development, compilation and execution of Java programs is taken care by JDK which contains 2 main components: Development tools and JRE.

The development tools consist of Java compiler and Java launcher.

- Java compiler (javac.exe) - It is the primary Java compiler. The compiler accepts Java source code and produces Java bytecode conforming to the Java Virtual Machine Specification (JVMS).

- Java launcher (java.exe) - It helps in launching a Java application during execution.

Next, let us discuss about Java Runtime Environment (JRE).

The Java Runtime Environment (JRE) contains Java Virtual Machine(JVM) and the Java standard library (Java Class Library).

- Java Virtual Machine (JVM) - It is the virtual machine that enables the computer to run Java programs.

- Java standard library (Java Class Library) - It is a set of dynamically loadable libraries that Java applications can call at run time. Java Platform is not dependent on a specific operating system and hence applications cannot rely on any of the platform-native libraries. So, the Java Platform provides a set of standard class libraries containing functions common to modern operating systems.

how does a Java program get executed by the computer.

- The Java source code is saved in a file with .java extension. When we compile a Java program (.java file), .class files (byte code) with the same class names present in .java file are generated by the Java compiler (javac). These .class files go through various steps when we run the program as shown in the below diagram.

## Platform Indepent

If a program written on a particular platform can run on other platforms without any recompilation, it is known as a platform independent program.

Usually larger applications are created by a team of developers. While most of them could be working on the same operating system such as Windows, others might be using different operating systems like Mac or Linux. In this scenario, we might have a situation where a program written on Windows needs to be executed on Mac OS also. 

Since Java is platform independent, it is not a problem. A program written using Java on Windows will execute without any recompilation on any other platform.

## Features
- Simple
- Robust
- Architecchural Neutral
- Secure
- Mutlti threaded

# Program
```
class Tester {
	public static void main(String[] args) {
		// Implement your code here 
		int principal = 5000, rate = 10, time = 5;
		System.out.println((principal*rate*time)/100)
		
	}
}
```

Implement a program to find and display the maximum number out of the given three numbers

```
class Tester {
	public static void main(String[] args) {
		// Implement your code here 
		int num1 = 3, num2 = 4, num3 = 1;
		if ((num1 > num2) && (num1 > num3)){
		    System.out.println(num1);
		}else if((num2 > num1) && (num2 > num3)){
		    System.out.println(num2);
		}else{
		    System.out.println(num3);
		}
	}
}

```

# OOP

- Object Oriented Programming(OOP) is a type of programming approach which enables the programmers to work with real life entities like Customer, Trainee, Employee, Company, Product, Food, Book, etc.

- Java, C#, Simula, JavaScript, Python, C++, Visual Basic .NET, Ruby, Scala, PHP etc. are some of the popular object-oriented programming languages.

- OOP helps a programmer in breaking down the code into smaller modules. These modules (classes) will have state(represented by attributes/variables) and functionality (represented by behavior/methods).

- These modules can then be used for representing the individual real life entities known as objects.

- E.g. - We can have a class named Customer to represent the state and behavior of all customers. Each individual customer can then be represented using an object of the Customer class.

# Access Modifier:
- So far, you have been using "public" and "private" keywords in your code. These keywords are called access modifiers.

- You will now understand them in more details.

- They are used to specify access levels to control the visibility of a class and its members. This facilitates encapsulation. There are 4 such access modifiers in Java:

1. Public: Accessible from any other class

2. Private: Accessible only inside its own class

3. Protected: Accessible inside the same package and to the sub-classes in different packages. This will be discussed in detail later in the course.

4. Default: Accessible inside the same package. Members created without any access modifier will have this access.


# Array

- An array is a collection of values of the same data type, stored in contiguous memory locations and referred by the same name. It holds a fixed number of values, decided at the time of array declaration.

- In order to use array in Java, you need to declare an array along with a datatype. You can declare, create and initialize an array in the following ways:

- Declaring and initializing the array in one line:
- Syntax:
```
dataType[ ] arrayVarName = {elementsOfArraySeparatedByComma};
```
- Eg:
```
long[ ] restaurantContacts = { 9992346725L, 9992346726L, 9992346727L };
```
- Creating the array using new: 
- Syntax:
```
dataType[ ] arrayVarName = new dataType[size];
arrayVarName[index] = element;
```
- E.g.:
```
long[ ] restaurantContacts = new long [3]; // Creating an array of size 3 of long datatype
restaurantContacts [0] = 9992346725L;
restaurantContacts [1] = 9992346726L;
restaurantContacts [2] = 9992346727L;
```
- Declaring and creating the array in different lines: 
- Syntax:
```
dataType [] arrayVarName;
arrayVarName = new dataType[size];
arrayVarName[index] = element;
```
- E.g.:
```
long[] restaurantContacts;
restaurantContacts = new long[3];
restaurantContacts[0] = 9992346725L;
restaurantContacts[1] = 9992346726L;
restaurantContacts[2] = 9992346727L;
```

### Accessing the elements of an array

- Each value stored in an array is called as an element. Each element in an array is accessed, stored and retrieved using its position in the array, called index. Indexes in Java are zero-based, i.e., the valid range of indexes for the elements of an array is from 0 to (size of Array-1).

```
long[] restaurantContacts = new long[3];
restaurantContacts [0] = 9992346725L; // Elements can be updated and accessed with the help of index
restaurantContacts [1] = 9992346726L;
restaurantContacts [2] = 9992346727L;
System.out.println(restaurantContacts [1]) ;// Accessing and displaying the element at the 1st index  

```

### Using for loop

Instead of writing n number of lines to access n elements of an array, you can use different looping constructs like for loop, for-each loop, etc.

The below code shows how to access and display the elements of restaurantContacts with the help of for loop.
```
public class Tester {
	public static void main(String[] args) {
		long[] restaurantContacts = { 9992346725L, 9992346726L, 9992346727L };
		for (int index = 0; index < restaurantContacts.length; index++) {
			// Accessing element at position index
			System.out.println(restaurantContacts[index]);
		}
	}
}
```
Note: - The length attribute of an array is used to get its size

Java also has another loop known as for-each loop to iterate over collections. This eliminates the use of indexes. It displays the array elements one by one. It holds an array element in a variable and then executes the body of the loop.

Syntax:
```
for (dataType variable: array) { 
	//body of the loop 
} 
```
The below code displays the elements of restaurantContacts array using the for-each loop.
```
public class Tester {
	public static void main(String[] args) {
		long[] restaurantContacts = { 9992346725L, 9992346726L, 9992346727L };
		for (long contactNumber : restaurantContacts) {
			System.out.println(contactNumber);
		}
	}
}
```

# Multi dimensional Array

Next, you will learn about Multi-dimensional arrays.

Multi-dimensional arrays are arrays of arrays with each element of the array holding the reference of other arrays. A multi-dimensional array is created by appending one set of square brackets ([]) per dimension.

Let's see a simple example to declare, instantiate, initialize and display a 2-dimensional (2D) array.

Syntax for creating 2D array:
```
dataType[][] arrayVarName = new dataType[rowsize][columnsize];
```
Note: The second dimension, i.e., the column size is optional.

E.g.
```
//Here, the row size is 7, and the column size is 2
//The 0th index stores the Max temperature and 1st index stores the Min temperature
int[][] dayWiseTemperature = new int[7][2];    
dayWiseTemperature[0][0]=29; // Initialization 
dayWiseTemperature[0][1]=21;
//and so on
//Another way of creating and initializing 2D array 
int[][] dayWiseTemperature = new int[][]  {{29,21},
		{24,23},
		{26,22},
		{28,23},
		{29,24},
		{23,20},
		{29,21}};
```

The below code shows how to update and display an element of a 2D array
```
//Updating an element of a 2D array 
dayWiseTemperature[2][0]=33;
//Displaying value of an element of a 2D array 
System.out.println(dayWiseTemperature[2][0]); 
```

# Points

Some of the important points that you should be knowing about arrays are:

- An array is a collection of similar data in contiguous memory locations referred by the same name

- Can be used to store data of primitive as well as reference types

- Holds a fixed number of values, determined at the time of array declaration

- Array index always starts from zero

- The length attribute of an array can be used to get its size

- Once initialized, the size of an array cannot be changed

### Command Line argumnet

Now that you know arrays, you will be able to notice something familiar in the code that you have already seen.
```
public static void main( String[] args) {
		// Code 
	}
```
String args[] is an array of strings. 

How are values passed to this array?

Values are passed to this array using command-line arguments. Such arguments are passed as inputs to your program either through the command prompt of your system or through the run configuration of your IDE.

Create a class named Greetings as shown below.
```
public class Greetings{
     public static void main(String[] args){
          System.out.println("Hello"+args[0]);
     }
}
```
The main method accepts inputs through the String[] args and displays the output using it.

# String

- String is used to store a sequence of characters. String is a predefined class in Java and comes with many methods which can help us perform various operations on it. 

- There are two ways to create a string: 

1. String literal 
```
        String customerName = "Jasmine"; 
```
2. Using new() keyword 
```
        String customerName = new String("Jasmine"); 
```

- Every time you create a string literal, the JVM checks the String constant pool. String constant pool in Java is a pool of Strings stored in Heap memory. If the string exists in the pool, then a reference to the existing literal is returned. If the string is not found, then a new instance is created and placed in the pool. 

- In the below diagram, since the value of newName is also Max, new memory is not allocated for newName and newName points to the same memory location as name does.

- String name = "MAX"
- String newName = "MAX"
- In name==newName will be true.

- Strings behave a bit differently when a new instance of String class is created. When you create a string using the new() keyword, JVM places the literal in the constant pool and also creates a new string object in heap memory. The reference variable points to the object in the heap memory.

- In the below example, either 1 or 2 strings will be created. If there is already a string literal "Welcome" in the pool, then only one string will be created. If there is no string literal "Welcome" in the pool, then it will be first created in the pool and then in the heap memory resulting in creation of 2 String objects. 

- String str = new String("Welcome")
- String newStr = new String("Welcome")
- str == newStr will be false.

## Debugging

pending

# Static
- When a variable is declared as Static, then a single copy of the variable is created and shared among all objects at the class level. Memory allocation for such variables happen only once when the class is loaded in the memory. These variables are also known as class-level variables.

- Since static variables and instance variables are both members of the class, they are often referred to as member variables.

- To create a static member variable, precede its declaration with the keyword static. When a member is declared static, it can be accessed before any object of the class is created and without reference to any object. 

- Syntax:
```
private static float deliveryCharge; //Declaration of static variable 
```

- Since the static variable gets created only once, now only one deliveryCharge member variable will be created and all the objects of that class will share that member variable. This can be visualized as

- How can we initialize the static variables?

- One way to initialize the static variable is to initialize at the time of declaration as shown below
```
private static float deliveryCharge = 1.5f; 
```
- This is fine if you have to directly initialize a value but this would not work if you need to perform some computation and then initialize the value of a static member variable. 

- In that case, Java provides one more type of static member called static block.

## Static Block

- Static blocks are used to initialize static variables when it cannot be done in a single line. They can also be used to add preprocessing if required.

- In the scenario of the delivery charge, the static variable deliveryCharge can be initialized with the help of static block as shown below
```
static {
    deliveryCharge = 1.5f; // initialize the static variable
    }
```

- Static blocks get executed only once when a class gets loaded in memory. If there are multiple static blocks, they will be executed in the order of their occurrence.

- After implementing static variable and static block, the Customer class looks as shown below.

```
class Customer {
	private String customerId;
	private String customerName;
	private long contactNumber;
	private String address;
	private static float deliveryCharge;
	static {
		deliveryCharge = 1.5f;
	}
	public Customer(String customerId, String customerName, long contactNumber,
			String address) {
		this.customerId = customerId;
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	public String getCustomerId() {
		return customerId;
	}
	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}
	public String getCustomerName() {
		return customerName;
	}
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	public long getContactNumber() {
		return contactNumber;
	}
	public void setContactNumber(long contactNumber) {
		this.contactNumber = contactNumber;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	public void displayCustomerDetails() {
		System.out.println("Displaying customer details \n***********");
		System.out.println("Customer Id : " + customerId);
		System.out.println("Customer Name : " + customerName);
		System.out.println("Contact Number : " + contactNumber);
		System.out.println("Address : " + address);
		System.out.println();
	}
	public double payBill(double totalPrice) {
		double discountPercentage = 5;
		System.out.println("Calculating final amount to be paid.....");
		double priceAfterDiscount = totalPrice * (1 - (discountPercentage / 100));
        double finalBillAmount=priceAfterDiscount + deliveryCharge;
		return finalBillAmount;
	}
}

```

## Static Method

- How can you access the static variable deliveryCharge in order to display the total bill amount which has to be paid by the customers?

- One way of accessing the static variable is with the help of instances of the class as shown below.

```
// Accessing the static variable with the help of instance of the class
System.out.println("Delivery Charge for customer1 is "+ customer1.deliveryCharge);
```
- Since the static variables are not specific to an object, accessing a static variable using an object is not the correct way.

- Instead, static variables should be accessed with the help of class name instead of the instance of the class as shown below:

```
// Accessing the static variable with the help of class
System.out.println("Delivery Charge for customer1 is "+ Customer.deliveryCharge);
```

- To update or retrieve the value of a static variable, you need to use the setter and getter methods.

- Since static variable is not specific to an object, you need a way to access the setter and getter methods without an object. This is possible by creating static methods.

- Static methods are methods prefixed with the static keyword. These methods can be accessed without an object of the class. Similar to static variables, they are accessed using the class name. A static method can be invoked without creating an instance of a class.

- A static method can only access static variables and cannot access instance variables.

- In case of the delivery charge scenario, you can create static setter and getter methods for deliveryCharge as shown below
```
public static float getDeliveryCharge() {
	return deliveryCharge;
}
public static void setDeliveryCharge(float deliveryCharge) {
	Customer.deliveryCharge = deliveryCharge;
}
```

- What happens if you try to access the deliveryCharge in setDeliveryCharge() method with the help of this?
```
public static void setDeliveryCharge(float deliveryCharge) {
	// Which object's deliveryCharge?
	this.deliveryCharge = deliveryCharge; // This line will throw error 
	}
```
- Static blocks and static methods cannot access non-static (instance) members directly since static methods do not belong to any object, so it is not possible to know which object's instance variables should be accessed. Trying to do so will result in a compilation error.

- However, non-static methods can access static members.

- The following code shows the implementation of Customer class with static variables, static blocks and static methods.

```
class Customer {
	private String customerId;
	private String customerName;
	private long contactNumber;
	private String address;
	private static float deliveryCharge;
	static {
		deliveryCharge = 1.5f;
	}
	public Customer(String customerId, String customerName, long contactNumber, String address) {
		this.customerId = customerId;
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	public String getCustomerId() {
		return customerId;
	}
	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}
	public String getCustomerName() {
		return customerName;
	}
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	public long getContactNumber() {
		return contactNumber;
	}
	public void setContactNumber(long contactNumber) {
		this.contactNumber = contactNumber;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	public static float getDeliveryCharge() {
		return deliveryCharge;
	}
	public static void setDeliveryCharge(float deliveryCharge) {
		Customer.deliveryCharge = deliveryCharge;
	}
	public void displayCustomerDetails() {
		System.out.println("Displaying customer details");
		System.out.println("Customer Id: " + this.customerId);
		System.out.println("Customer Name: " + this.customerName);
		System.out.println("Contact Number: " + this.contactNumber);
		System.out.println("Address: " + this.address);
		System.out.println("Delivery Charge: " + Customer.deliveryCharge);
		System.out.println();
	}
	public double payBill(double totalPrice) {
		double discountPercentage = 5;
		System.out.println("Calculating final amount to be paid.....");
		double priceAfterDiscount = totalPrice * (1 - (discountPercentage / 100));
		double finalBillAmount = priceAfterDiscount + Customer.deliveryCharge;
		return finalBillAmount;
	}
}
public class Tester {
	public static void main(String[] args) {
		Customer customer1 = new Customer("C1001", "Sam", 9945000009L, "Carolina Street, Springfield, 62702");
		Customer.setDeliveryCharge(2f);
		System.out.println("Final amount to be paid: $" + customer1.payBill(20));
		Customer customer2 = new Customer("C1002", "John", 9645000009L, "Carolina Street, Springfield, 62708");
		System.out.println("Final amount to be paid: $" + customer2.payBill(15));
		System.out.println("Delivery Charge for the customers are: " + Customer.getDeliveryCharge());
	}
}

```

- Another most common implementation of the static concept is in auto-generation of Ids.

Let us assume that we want to generate the customer Ids for all the customers. All the customer Ids must be unique and it should start with 'C101'. In order to implement this requirement and generate the customerId for all the customers, the concept of static is used as shown below.

```
class Customer {
	private static int counter; // Declaring the static variable counter
	private String customerId;
	private String customerName;
	private long contactNumber;
	private String address;
	private static float deliveryCharge;
	static {
		deliveryCharge = 1.5f;
		counter = 100; // Initializing the static variable counter
	}
	public Customer(String customerName, long contactNumber, String address) {
		// Incrementing the counter and initializing customerId
		this.customerId = "C" + ++Customer.counter;
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	// Static method to get the value of static variable counter
	public static int getCounter() {
		return counter;
	}
	// Static method to change the value of static variable counter if needed
	public static void setCounter(int counter) {
		Customer.counter = counter;
	}
	public String getCustomerId() {
		return customerId;
	}
	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}
	public String getCustomerName() {
		return customerName;
	}
	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}
	public long getContactNumber() {
		return contactNumber;
	}
	public void setContactNumber(long contactNumber) {
		this.contactNumber = contactNumber;
	}
	public String getAddress() {
		return address;
	}
	public void setAddress(String address) {
		this.address = address;
	}
	public static float getDeliveryCharge() {
		return deliveryCharge;
	}
	public static void setDeliveryCharge(float deliveryCharge) {
		Customer.deliveryCharge = deliveryCharge;
	}
	public void displayCustomerDetails() {
		System.out.println("Displaying customer details");
		System.out.println("Customer Id: " + this.customerId);
		System.out.println("Customer Name: " + this.customerName);
		System.out.println("Contact Number: " + this.contactNumber);
		System.out.println("Address: " + this.address);
		System.out.println("Delivery Charge: " + Customer.deliveryCharge);
		System.out.println();
	}
	public double payBill(double totalPrice) {
		double discountPercentage = 5;
		System.out.println("Calculating final amount to be paid.....");
		double priceAfterDiscount = totalPrice * (1 - (discountPercentage / 100));
		double finalBillAmount = priceAfterDiscount + Customer.deliveryCharge;
		return finalBillAmount;
	}
}
public class Tester {
	public static void main(String[] args) {
		Customer customer1 = new Customer("Sam", 9945000009L, "Carolina Street, Springfield, 62702");
		Customer customer2 = new Customer("John", 9645000009L, "Carolina Street, Springfield, 62708");
		Customer customer3 = new Customer("Alex", 9745000009L, "Carolina Street, Springfield, 62768");
		System.out.println("Customer Id for the first customer is: " + customer1.getCustomerId());
		System.out.println("Customer Id for the second customer is: " + customer2.getCustomerId());
		System.out.println("Customer Id for the third customer is: " + customer3.getCustomerId());
	}
}

```

## Static Tryout:
```
class Tester {
	public static void main(String[] args) {
		Car c1 = new Car("Red");
		Car c2 = new Car("Green");
		Car c3 = new Car("Blue");
		System.out.println("Number of cars created: " + Car.getNumberOfCars());
	}

	static {
		System.out.println("Tester class loaded");
	}
}

class Car {
	private String color;
	private static int numberOfCars = 0;

	static {
		System.out.println("Car class loaded");
	}

	public Car(String color) {
		this.color = color;
		Car.numberOfCars += 1;
	}

	public String getColor() {
		return this.color;
	}

	public static int getNumberOfCars() {
		return numberOfCars;
	}
}

```

# Association

- Association, also known as uses-a relationship exists between two classes when one object makes use of another object for its functionality. Here, both the objects can exist independently.


# Encapsulation

- Restrict certain parts of the code from directly accessing sensitive data.

# Inheritance

- Now, let us consider RegularCustomer and Guest classes. Since RegularCustomer and Guest are types of Customers, they must have access to the common attributes also. We can create a Customer class with the common attributes and methods and make these two classes inherit the attributes and behavior from Customer class.
- We can say that the RegularCustomer "is-A" Customer and Guest "is-A" Customer. When a class inherits from another class, then those classes are said to have inheritance relationship. The class which is inheriting is called the child/sub/derived class and the class which is getting inherited is called the parent/super/base class. Inheritance is also called as "is-A" relationship. Inheritance (is-a) is denoted by a line with an arrow head. 
- In case of an inheritance relationship, the attributes and behaviors get inherited just like a child inherits certain attributes and behaviors from his/her parent. 

- In terms of OOP, a child class inherits all the non-private attributes and methods.

- When we say a child class inherits the attributes and methods, we can treat the attributes and methods as if they are owned by the child class itself.

- In Java, a child class inherits the parent class using the "extends" keyword. Observe the below code.

```
class Customer {
	//Parent/Super/Base class
}
class RegularCustomer extends Customer {        // RegularCustomer is a Customer
	//Child/Sub/Derived class
}
class Guest extends Customer {                  // Guest is a Customer
	//Child/Sub/Derived class
}
```

# Constructor call inheritance

- By now, you have learnt that the derived classes inherit from the base class. You will now see how the child class object is created. As you all know, constructors are invoked while creating objects. When a child class object is created, the child class constructor invokes the parent class constructor before executing any statement present in the child constructor.

- Observe the below code and understand the sequence of constructor invocation.

```
class Customer {
	public Customer() {
		// 3: Parent constructor will be executed
		System.out.println("Creating a customer...");
		// 4: The flow will go back to the child constructor
	}
}
class RegularCustomer extends Customer {
	public RegularCustomer() {
		// 2: This constructor will then call the parent constructor
		System.out.println("It is a regular customer!");
		// 5: The flow will finally come here
	}
}
public class Tester {
	public static void main(String[] args) {
		RegularCustomer regularCustomer = new RegularCustomer();
		// 1: This line will be executed first and the flow will go to [2]
	}
}

```

# Need for super constructors
 
```
class Customer {

	private String customerId;
	private String customerName;

	public Customer(String customerId, String customerName) {
		this.customerId = customerId;
		this.customerName = customerName;
	}

	public Customer() {
		System.out.println("Parent parameterless constructor");
	}

	public String getCustomerId() {
		return customerId;
	}

	public void setCustomerId(String customerId) {
		this.customerId = customerId;
	}

	public String getCustomerName() {
		return customerName;
	}

	public void setCustomerName(String customerName) {
		this.customerName = customerName;
	}

	public void displayCustomerDetails() {
		System.out.println("Displaying customer details \n***************************");
		System.out.println("Customer Id : " + this.customerId);
		System.out.println("Customer Name : " + this.customerName);
		System.out.println();
	}

}

class RegularCustomer extends Customer {

	private float discount;

	public RegularCustomer(String custId, String custName) {

		this.setCustomerId(custId);
		this.setCustomerName(custName);
		this.discount = 5.0f;
		System.out.println("Child parameterized constructor");
	}

	public float getDiscount() {
		return discount;
	}

	public void setDiscount(float discount) {
		this.discount = discount;
	}

}

class Tester {

	public static void main(String[] args) {

		RegularCustomer regularCustomer = new RegularCustomer("C1010", "Johns Kora");
		regularCustomer.displayCustomerDetails();

	}
}

```

- In the previous code snippet, the member variables were being set in the child class constructor and the parameterized constructor of parent class.

- Instead of setting the values of member variables in both the places, it would be better if the parameterized constructor of parent class is invoked from the child class constructor so that code can be reused. 

- By now, you know that the parent class parameterless constructor is implicitly invoked by the child class constructors but how are parameterized constructors of parent class invoked? 

- This can be done using super as shown in the code given below.

```
class Customer {
	private String customerId;
	private String customerName;
	public Customer(String customerId, String customerName) {
		this.customerId = customerId;
		this.customerName = customerName;
	}
	public void displayCustomerDetails() {
		System.out.println("Displaying customer details \n***************************");
		System.out.println("Customer Id : " + this.customerId);
		System.out.println("Customer Name : " + this.customerName);
	}
}
class RegularCustomer extends Customer {
	private float discount;
	public RegularCustomer(String custId, String custName) {
		super(custId, custName); // Invoking the parent class parameterized constructor
		this.discount = 5.0f;
	}
	public float getDiscount() {
		return discount;
	}
	public void setDiscount(float discount) {
		this.discount = discount;
	}
}
public class Tester {
	public static void main(String[] args) {
		RegularCustomer regularCustomer = new RegularCustomer("C1010", "Johns Kora");
		regularCustomer.displayCustomerDetails();
	}
}

```

- Please also note that the call to a super constructor has to be the first statement inside a constructor.

- In fact, the parameterless constructor of the parent class gets implicitly called by the child class constructors due to an implicit super() statement. This can also be done explicitly as shown below.

```
class RegularCustomer extends Customer {
	public RegularCustomer() {
		super(); // Invoking the parent class constructor
		System.out.println("It is a regular customer!");
	}
}

```

- Observe the code given below. The object of child class is getting created by passing parameters to the child class constructor but the variables get initialized using the parent class constructor.

```
class Employee {
	int employeeId;
	String employeeName;

	// Parameterized constructor
	Employee(int employeeId, String employeeName) {
		this.employeeId = employeeId;
		this.employeeName = employeeName;
	}

	public int getEmployeeId() {
		return employeeId;
	}

	public void setEmployeeId(int employeeId) {
		this.employeeId = employeeId;
	}

	public String getEmployeeName() {
		return employeeName;
	}

	public void setEmployeeName(String employeeName) {
		this.employeeName = employeeName;
	}

	public void display() {
		System.out.println("Employee details");
		System.out.println("Employee Id: " + employeeId);
		System.out.println("Employee Name: " + employeeName);
	}
}

class Manager extends Employee {
	private String designation;

	Manager(int employeeId, String employeeName, String designation) {
		super(employeeId, employeeName);
		this.designation = designation;
	}

	public String getDesignation() {
		return designation;
	}

	public void setDesignation(String designation) {
		this.designation = designation;
	}
}

class Tester {
	public static void main(String[] args) {
		Manager obj = new Manager(101, "John", "Lead");
		obj.display();
		System.out.println("Designation: " + obj.getDesignation());
	}
}
```

# Types of inheritances

- Single Inheritance : one class is extended by only one class. 
```
public class Customer {
	// Parent/Super/Base class
}
public class RegularCustomer extends Customer {        // RegularCustomer is a Customer
	// Child/Sub/Derived class
}
```

- Multilevel inheritance : In multilevel inheritance, a class extends another class which extends another class.


```
public class Customer {
    //code	
}
public class RegularCustomer extends Customer {     
     //code   
}
public class PremiumCustomer extends RegularCustomer {  
     //code  
   
}
```

- Hierarchical Inheritance : When more than one class extends the same base class, then that type of inheritance is said to be Hierarchical Inheritance.

```
public class Customer {
	// code here
}
public class RegularCustomer extends Customer {
	// code here
}
public class Guest extends Customer {
	// code here
}
```

- Multiple Inheritance : In Multiple Inheritance, one class extends multiple classes. Please note that Multiple Inheritance is NOT supported in many object oriented programming languages including Java.

# The main advantages of inheritance are:

- Code reusability - The codes are defined only once and can be used multiple times. We define the functionalities in the parent class and any number of child classes can use the functionalities at any time.

- Saves time and effort due to reusability of code.

- Inheritance makes the application code more flexible to changes

- Inheritance results in better organization of codes into smaller and simpler compilation units which makes the code more readable and easy to debug

# Method Ovverloading

# Polymosrphism

Polymorphism is the ability of an object to take different forms, i.e., a single action that can be performed in different ways. So, polymorphism means many forms.

Consider a simple example of a Bank. All the banks are providing loans to its customers.

But are they all providing it at the same rate?

No, rate of interest may differ from bank to bank. So, object of the Bank class may behave differently when we try to get the interest rate for bank loans (through a method).

The Bank class, here, shows polymorphism.

Polymorphishm is of two types:

1. Static polymorphism

2. Dynamic polymorphism

Polymorphism that gets resolved during compile time is known as static polymorphism or compile time polymorphism. This polymorphism is achieved using overloading of the methods in the same class, called as Method overloading.

Method overloading allows the programmer to have multiple methods with the same name in the same class, but differing in their signature.

Signature can differ by

1. the number of parameters

2. the data type of parameters

3. the order of the parameters

Note: We cannot overload methods by their return type, i.e., two or more methods are not overloaded if they differ only in their return type.

## Static

Let us assume that later, the app provides another feature for the customers to change their address so that they can provide another delivery location.

Now, we will add another method, updateAddress(Address address) as given below:
```
public class Customer {
	private String customerId;
	private String customerName;
	private long contactNumber;
	private Address address;
	public void updateContact(long mobile) {
		System.out.println("Updating customer contact number...");
		this.setContactNumber(mobile);
	}
	public void updateAddress(Address address) {
		System.out.println("Updating customer address...");
		this.setAddress(address);
	}
	// Constructors and other methods
}
```
So, here different methods are getting added to the code which are basically doing the same thing of updating the customer details which can be either contact number or address or any other details.

Thus, is there any need of having these methods with a different name?

No, since we have the option of creating overloaded methods, i.e., methods with same name differing in signature, we can use overloaded methods in this scenario.

Here, the advantage is that we don’t have to create and remember different names for methods doing same functionality. For example, if overloading was not supported, we would have to create different method names like updateContact, updateAddress, updateContactAddress etc.

#### Modified code of static 

Considering this, our code will be modified as shown below:

public class Customer {
	private String customerId;
	private String customerName;
	private long contactNumber;
	private Address address;
	public void updateDetails(long mobile) {
		System.out.println("Updating customer contact number...");
		this.setContactNumber(mobile);
	}
	public void updateDetails(Address address) {
		System.out.println("Updating customer address...");
		this.setAddress(address);
	}
	// Constructors and other methods
}
Here, the Customer class is having two methods (having same behavior of updating the customer details) with same name: updateDetails() but both the methods differ in the data type of the parameter. This is Method Overloading and both the updateDetails methods are said to be overloaded methods.

Overloaded methods are invoked just the usual way, where the method which matches the signature is invoked.

public class Tester {
	public static void main(String[] args) {
		Customer customer = new Customer("C1016", "Stephen Abram", 7856341287L, custAddress);		
			
		Long newContact = 7890098656L;
		Address newAddress = new Address("D119", "St. Louis Street", "Springfield", 62729);
		
		customer.updateDetails(newContact); //calls the updateDetails(long mobile) - based on the parameter
        customer.updateDetails(newAddress); //calls the updateDetails(Address address) - based on the parameter	
}

Calls to the overloaded methods can be resolved based on the method signature during compilation and thus the name compile-time or static polymorphism.


# Constructore overlaoding

Just like normal methods, constructors can also be overloaded, i.e., a class can have multiple constructors. This is called constructor overloading. Remember that you have already seen a class having multiple constructors.

The below code demonstrates constructor overloading.
```
class Customer {
	private String customerId;
	private String customerName;
	private long contactNumber;
	private Address address;
	// Parameterless constructor
	public Customer() {
		System.out.println("Inside parameterless constructor");
	}
	// Parameterized constructor
	public Customer(String customerId, String customerName, long contactNumber,
			Address address) {
		this.customerId = customerId;
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	// Parameterized constructor
	public Customer(String customerName, long contactNumber, Address address) {
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	// Methods including getter and setter and other methods
}
public class Tester {
	public static void main(String[] args) throws Exception {
		/*
		 Parameterless constructor will be invoked, instance variables should
		 be initialized using setter methods
		 */
		Customer customerOne = new Customer();
		/*
		 Parameterized constructor with four parameters instance variables are
		 initialized in the constructor
		 */
		Customer customerTwo = new Customer("C1016", "Stephen Abram",
				7856341287L, new Address("D089", "St. Louis Street",
						"Springfield", 62729));
		/*
		 Parameterized constructor with three parameters instance variables
		 are initialized in the constructor
		 */
		Customer customerThree = new Customer("James Jonathan", 7828171287L,
				new Address("D159", "St. Louis Street", "Springfield", 62729));
	}
}
```

# Method Ovverriding

Similar to static polymorphism or compile time polymorphism, polymorphism can also be achieved at runtime. Such type of polymorphism is known as dynamic polymorphism. This type of polymorphism is achieved using overriding the parent method in the child class, called as Method Overriding.

Overriding feature allows the programmer to have a different implementation of parent methods with the same signature in the child classes. Such parent methods are said to be overridden.

When we override a method in the child class, it should have the same signature as that of the parent class.

The method should not have a weaker access modifier.

Private methods are not overridden.

## Need of MOR

Consider the parent Customer class. 

All the customers’ need to pay the bill amount calculated for their orders. There is a payBill() in the Customer class for calculating the final amount for bill payment.

You need to also remember that calculation of bill amount differs for each type of customer. Guests needs to pay a delivery charge of $2. Regular customers get a discount of 5%. Premium customers get a discount of 8% and they can use membership card points for paying the bill.

Since the final amount calculation which is done in the payBill() of parent Customer class will not suit for all the customer types, we need to have separate implementation for this method in each of the child classes with respect to each customer type.

So, in this scenario, the payBill() of the child classes will override the implementation of payBill() present in the parent class. This is said to be method overriding.

public class Customer {
	private String customerId;
	private String customerName;
	private long contactNumber;
	private Address address;
	public Customer(String customerId, String customerName, long contactNumber,
			Address address) {
		this.customerId = customerId;
		this.customerName = customerName;
		this.contactNumber = contactNumber;
		this.address = address;
	}
	public double payBill(double totalPrice) {
		System.out.println("Final bill for the customer is calculated here");
		return totalPrice;
	}
	// displayCustomerDetails()
	// updateDetails() overloaded methods
	// getter and setter methods
}

In the below code, payBill() is overridden in the RegularCustomer to include the 5% discount.

public class RegularCustomer extends Customer {
	private float discountPercentage;
	public RegularCustomer(String custId, String custName, long mobileNo,
			Address address) {
		super(custId, custName, mobileNo, address);
		this.discountPercentage = 5.0f;
	}
	@Override
	public double payBill(double totalPrice) {
		double priceAfterDiscount = totalPrice
				* (1 - (discountPercentage / 100));
		return priceAfterDiscount;
	}
	// getter and setter methods
}

- Case 1

We will now see how these overridden methods can be invoked. Consider the Tester class given below:

public class Tester {
	public static void main(String[] args) {
		// Customer object created
		Customer customer = new Customer("C101", "Stephen Abram", 7856341287L,
				new Address("D089", "St. Louis Street", "Springfield", 62729));
		// payBill() is invoked
		double amount = customer.payBill(40.0);
		System.out.println("Final bill amount is $" + (int) (amount * 100)/ 100.0);
	}
}
Which method do you think will be invoked?

In the above case, payBill() from the parent class Customer will be invoked and the output will be:

Final bill for the customer is calculated here

Final bill amount is $40.0

- Case 2

Now consider the below code:

//Regular Customer object created
RegularCustomer regularCustomer = new RegularCustomer("C101",
		"Stephen Abram", 7856341287L, new Address("D089",
				"St. Louis Street", "Springfield", 62729));
// payBill() is invoked
double amount = regularCustomer.payBill(40.0);
System.out.println("Final bill amount is $" + (int) (amount * 100)/ 100.0);
Which method do you think will be invoked in this case?

In the above case, payBill() of the child class RegularCustomer will be invoked and the output will be:

Final bill amount is $37.99

- Case 3:

Now, consider another case of calling an overridden method.

Customer regularCustomer = new RegularCustomer("C101", "Stephen Abram", 7856341287L, new Address("D089", "St. Louis Street", "Springfield", 62729));
double amount = regularCustomer.payBill(40.0);

Which method do you think will be invoked in this case?

The answer is payBill() of the child class RegularCustomer.

# Dynamic Binding

You will now understand the reason behind the output of the previous code.

A parent class reference can refer to a child class object.

		(Parent refernce)
Customer regularCustomer = new RegularCustomer();
								(Child Obj)

Only the overridden methods can be called using the parent class reference. Any new method created in the child class will not be accessible using the parent class reference. 

The version of the method that will be called is determined by the object, and this decision is taken at runtime. This is called Dynamic binding.

Static methods are not overridden. They will be called based on the type of reference used.

Note: When a base class is specialized into child classes, instantiating the base class is not a good practice.


# Genric Method Tryout

Dynamic binding also allows the programmer to have generic methods.
Generic methods will have the parent type as the formal argument. Such methods accepting the parent type allows working with the objects of it as well as child type.
The code given below shows an example of a generic method accepting the parent reference as the argument.


```
class DynamicBindingTester {
	public static void main(String[] args) {
		Employee employee = new Employee();
		Manager manager = new Manager();
		Employee eduEmployee = new Educator();
		Educator managerEdu = new Manager();
		
		displayEmployeeDetails(employee);
		displayEmployeeDetails(manager);
		displayEmployeeDetails(eduEmployee);
		displayEmployeeDetails(managerEdu);
	}
	
	// Employee reference can accept its object and any of the child object 
	public static void displayEmployeeDetails(Employee employee) {
		employee.displayDetails();	// displayDetails invoked will be based on the object received
	}
}

class Employee {
	String name = "James Anthony";
	
	public void displayDetails(){
		System.out.println(name+" is an employee");
	}	
}
class Educator extends Employee {
	public void displayDetails(){
		System.out.println(name+" is an educator");
	}
}
class Manager extends Educator {
	public void displayDetails(){
		System.out.println(name+" is a manager");
	}
}

```

# Annotations

Have you noticed that @Override is mentioned on top of the overridden methods?

This is called an annotation. It is like an information for the compiler or JVM and provides additional meaning to the code.

An annotation is a meta-data that provides data about the program and is not part of the program itself.

Its purpose is to give additional information to the compiler, or for some processing during compile-time or runtime. It can be added to classes, methods, variables, parameters and packages.

The @Override annotation is used with methods which ensures that the method is actually overriding a parent method. If it is used on a method which does not override any parent method, a compilation error occurs.

What happens, if @Override annotation is not used with an overridden method?

While it is not required to use this annotation when overriding a method, it helps to prevent errors. If a method marked with @Override fails to correctly override a method from one of its super classes, the compiler generates an error.

Not having this annotation can cause warnings. But having this annotation with no super class that has a same method signature will result in an error.

@Override annotation helps in avoiding refactoring errors. If the method in the super class is renamed, but not the overridden method, then also it will give an error.

# Super

You have already seen that super keyword can be used to invoke the constructors of parent class.

super keyword can also be used for

invoking a parent class method from a child class method 

accessing a parent class instance variable in the child class in case there is a variable in the child class also with the same name

### Super Scenario

Consider the PremiumCustomer class which is the child class of RegularCustomer.

While calculating the final bill to be paid for the premium customer, discount needs to be applied but the discount value is different from that of a regular customer.

The code for PremiumCustomer class is as shown below:

class PremiumCustomer extends RegularCustomer {
	public PremiumCustomer(String custId, String custName, long mobileNo,
			Address address) {
		super(custId, custName, mobileNo, address);
		this.setDiscountPercentage(8.0f);
	}
	@Override
	public double payBill(double totalPrice) {
		double priceAfterDiscount = totalPrice
				* (1 - (this.getDiscountPercentage() / 100));
		return priceAfterDiscount;
	}
}
super is used in the child class constructor to call the parent class constructor.

Now consider the payBill() method in which final bill is calculated after applying discount.

The discount variable is initialized to the fixed value 8% in the constructor of the PremiumCustomer class and the calculation of the bill amount is done in the payBill method. The same calculation of applying discount is done in the payBill() method of the parent class, i.e.,  RegularCustomer class.

This redundant calculation can be avoided by calling the parent class method in the child class method using super.

payBill() method of the PremiumCustomer class will then look as follows:

@Override
public double payBill(double totalPrice) {
    double priceAfterDiscount = super.payBill(totalPrice);
    return priceAfterDiscount;
}

Here, payBill() method of the RegularCustomer will be called where the final bill amount will be calculated and returned to the payBill() method of the PremiumCustomer class.

- Let us have a look at one more code snippet.

public class Employee {
	public float salary = 25000f;
	// Other fields and methods
}
public class Manager extends Employee {
	private float salary;
	private float bonus;
	public void calculateSalary() {
		this.salary = super.salary + bonus;
	}
	public void getBonus() {
		return bonus;
	}
	public void setBonus(float bonus) {
		this.bonus = bonus;
	}
	public void getSalary() {
		return salary;
	}
	public void setSalary(float salary) {
		this.salary = salary;
	}
}
public class Tester {
	public static void main(String[] args) {
		Manager manager = new Manager();
		manager.setBonus(2000f);
		manager.calculateSalary();
		System.out.println("Manager Salary : " + manager.getSalary());
	}
}
In the above given code, salary attribute is present in both the parent (Employee) and the child (Manager) but the salary component of Manager class will be having an additional component of bonus. In order to calculate the actual salary of the manager, fixed salary of the Employee class is required.

Thus, in order to access the instance variable of the parent class inside the child class, super is used.

# Comparison of MOL vs MOR

Method overloading is a feature through which a class can have multiple methods with the same name but different signature.

Method overriding is a feature that allows a subclass or child class to have a method with the same name and signature as that of the parent class.

Overloading is an example of compile-time polymorphism as the decision about which method has to be invoked is taken during compilation time.

Overriding is an example of runtime polymorphism as the decision about which method has to be invoked is taken during runtime.

# equals()

Why are the objects in the previous try out code different, even though the values of the member variables are same?

The == operator which is used to compare two Food objects compares the objects with respect to their memory address.

Thus, even though they have the same values of member variables, they are two different objects pointing to two different memory locations.

Whenever two objects are to be compared based on the values of the member variables, equals() method of Object class can be overridden.

equals() compares objects to check for equality

By default, equals() uses memory address to compare objects for equality (just like ==)

To make it work for different requirements, it needs to be overridden in the classes

// equals method of Object class overridden for comparing two Food objects
// based on foodName and foodType
public boolean equals(Object obj) {
	Food otherFood = (Food) obj;
	if (this.foodName.equals(otherFood.foodName)) {
		if (this.foodType.equals(otherFood.foodType))
			return true;
	}
	return false;
}
In the above scenario,

equals() returns true if the foodName and foodType of two Food objects are same

type casting is done for the received object to cast it to Food object

otherFood represents the second Food object received and is compared with the Food object using which equals() is invoked

## equal tryout

class Food {

	private String foodName;
	private String cuisine;
	private String foodType;
	private int quantityAvailable;
	private double unitPrice;

	public String getFoodName() {
		return foodName;
	}

	public void setFoodName(String foodName) {
		this.foodName = foodName;
	}

	public String getCuisine() {
		return cuisine;
	}

	public void setCuisine(String cuisine) {
		this.cuisine = cuisine;
	}

	public String getFoodType() {
		return foodType;
	}

	public void setFoodType(String foodType) {
		this.foodType = foodType;
	}

	public int getQuantityAvailable() {
		return quantityAvailable;
	}

	public void setQuantityAvailable(int quantityAvailable) {
		this.quantityAvailable = quantityAvailable;
	}

	public double getUnitPrice() {
		return unitPrice;
	}

	public void setUnitPrice(double unitPrice) {
		this.unitPrice = unitPrice;
	}

	// equals method of Object class overridden for comparing two Food objects
	// based on foodName and foodType
	@Override
	public boolean equals(Object obj) {
		Food otherFood = (Food) obj;
		if (this.foodName.equals(otherFood.foodName)) {
			if (this.foodType.equals(otherFood.foodType))
				return true;
		}
		return false;
	}
}

class Tester {

	public static void main(String[] args) {
		Food foodOne = new Food();
		foodOne.setFoodName("Sandwich");
		foodOne.setCuisine("Continental");
		foodOne.setFoodType("Veg");
		foodOne.setQuantityAvailable(100);
		foodOne.setUnitPrice(10);

		Food foodTwo = new Food();
		foodTwo.setFoodName("Sandwich");
		foodTwo.setCuisine("Continental");
		foodTwo.setFoodType("Veg");
		foodTwo.setQuantityAvailable(200);
		foodTwo.setUnitPrice(10);

		if (foodOne.equals(foodTwo)) {
			System.out.println("foodOne and foodTwo are same!");
		} else {
			System.out.println("foodOne and foodTwo are different!");
		}

		Food foodThree = new Food();
		foodThree.setFoodName("Burger");
		foodThree.setCuisine("Continental");
		foodThree.setFoodType("Veg");
		foodThree.setQuantityAvailable(100);
		foodThree.setUnitPrice(10);

		if (foodOne.equals(foodThree)) {
			System.out.println("foodOne and foodThree are same!");
		} else {
			System.out.println("foodOne and foodThree are different!");
		}
	}
}

# HashCode

Next, you will see the hashCode() method.

hashCode() uses an object's data to generate a hash value, which should be a 32 bit integer

By default, it derives the hash value based on the memory address of the object being used

If two objects are equal according to the equals() method, hashCode() must produce the same integer value for the two objects

It is important to understand that if the hash codes of two objects are same, it doesn't prove that the objects are equal, i.e., it is possible for two unequal objects to have the same hash codes. 

hashCode() uses a formula to generate an integer based on the same attribute

Any formula can be used for generating the hash code as long as it generates the same value for same objects
// hashCode method overridden
public int hashCode() {
	int result = 1;
	result = result + (foodName.hashCode());
	return result;
}
In the code snippet of equals() and in the code snippet given over here for hashCode(), equals() and hashCode() are applied on String.

The String class is also a subclass of the Object class. It already overrides the equals() and hashCode() methods.

Note: While comparing String objects for equality, equals() method should be used since it is already overridden to compare the values.

## Hascode tryout

```
class Food {

	private String foodName;
	private String cuisine;
	private String foodType;
	private int quantityAvailable;
	private double unitPrice;

	public String getFoodName() {
		return foodName;
	}

	public void setFoodName(String foodName) {
		this.foodName = foodName;
	}

	public String getCuisine() {
		return cuisine;
	}

	public void setCuisine(String cuisine) {
		this.cuisine = cuisine;
	}

	public String getFoodType() {
		return foodType;
	}

	public void setFoodType(String foodType) {
		this.foodType = foodType;
	}

	public int getQuantityAvailable() {
		return quantityAvailable;
	}

	public void setQuantityAvailable(int quantityAvailable) {
		this.quantityAvailable = quantityAvailable;
	}

	public double getUnitPrice() {
		return unitPrice;
	}

	public void setUnitPrice(double unitPrice) {
		this.unitPrice = unitPrice;
	}

	// equals method of Object class overridden for comparing two Food objects
	// based on foodName and foodType
	@Override
	public boolean equals(Object obj) {
		Food otherFood = (Food) obj;
		if (this.foodName.equals(otherFood.foodName)) {
			if (this.foodType.equals(otherFood.foodType))
				return true;
		}
		return false;
	}

	// hashCode method overridden
	@Override
	public int hashCode() {
		int result = 1;
		result = result + (foodName.hashCode());
		return result;
	}
}

class Tester {

	public static void main(String[] args) {
		Food foodOne = new Food();
		foodOne.setFoodName("Sandwich");
		foodOne.setCuisine("Continental");
		foodOne.setFoodType("Veg");
		foodOne.setQuantityAvailable(100);
		foodOne.setUnitPrice(10);

		Food foodTwo = new Food();
		foodTwo.setFoodName("Sandwich");
		foodTwo.setCuisine("Continental");
		foodTwo.setFoodType("Veg");
		foodTwo.setQuantityAvailable(200);
		foodTwo.setUnitPrice(10);

		if (foodOne.equals(foodTwo)) {
			System.out.println("foodOne and foodTwo are same!");
		} else {
			System.out.println("foodOne and foodTwo are different!");
		}

		System.out.println("Hash code for foodOne : " + foodOne.hashCode());
		System.out.println("Hash code for foodTwo : " + foodTwo.hashCode());

		Food foodThree = new Food();
		foodThree.setFoodName("Burger");
		foodThree.setCuisine("Continental");
		foodThree.setFoodType("Veg");
		foodThree.setQuantityAvailable(100);
		foodThree.setUnitPrice(10);

		if (foodOne.equals(foodThree)) {
			System.out.println("foodOne and foodThree are same!");
		} else {
			System.out.println("foodOne and foodThree are different!");
		}

		System.out.println("Hash code for foodOne : " + foodOne.hashCode());
		System.out.println("Hash code for foodThree : " + foodThree.hashCode());

	}
}

```

# STring comparison

Both == and equals() are used
```
class Tester {

	public static void main(String[] args) {
		String name1 = "Jennifer";
		String name2 = "Jennifer";
		String name3 = new String("Jennifer");

		System.out.println(name1 == name2); // both name1 and name2 refer to
											// same object
		System.out.println(name1 == name3); // name3 is a different object
											// created using new
		System.out.println(name2 == name3); // name3 is a different object
											// created using new

		System.out.println(name1.equals(name2));
		System.out.println(name1.equals(name3));
		System.out.println(name2.equals(name3));
		// Values are being compared in the above three cases and thus equals()
		// returns true

	}
}

```

# toString Method

Apart from equals() and hashCode(), the Object class provides another method named toString().

The toString() method returns a textual representation of an object.

By default, it returns a string consisting of the name of the object's class, the '@' character, and the unsigned hexadecimal representation of the hash code of the object. E.g. - Food@af7d0676

It should be overridden to provide a meaningful textual representation.

The returned text should be concise, easy to read and informative.

public String toString() {
}

## toString tryout

```
class Food {

	private String foodName;
	private String cuisine;
	private String foodType;
	private int quantityAvailable;
	private double unitPrice;

	public String getFoodName() {
		return foodName;
	}

	public void setFoodName(String foodName) {
		this.foodName = foodName;
	}

	public String getCuisine() {
		return cuisine;
	}

	public void setCuisine(String cuisine) {
		this.cuisine = cuisine;
	}

	public String getFoodType() {
		return foodType;
	}

	public void setFoodType(String foodType) {
		this.foodType = foodType;
	}

	public int getQuantityAvailable() {
		return quantityAvailable;
	}

	public void setQuantityAvailable(int quantityAvailable) {
		this.quantityAvailable = quantityAvailable;
	}

	public double getUnitPrice() {
		return unitPrice;
	}

	public void setUnitPrice(double unitPrice) {
		this.unitPrice = unitPrice;
	}

	// equals method of Object class overridden for comparing two Food objects
	// based on foodName and foodType
	@Override
	public boolean equals(Object obj) {
		Food otherFood = (Food) obj;
		if (this.foodName.equals(otherFood.foodName)) {
			if (this.foodType.equals(otherFood.foodType))
				return true;
		}
		return false;
	}

	// hashCode method overridden
	@Override
	public int hashCode() {
		int result = 1;
		result = result + (foodName.hashCode());
		return result;
	}

	// toString is overridden to provide a custom textual representation
	@Override
	public String toString() {
		return "Food -> " + "Food name: " + this.foodName + ", Cuisine: "
				+ this.cuisine + ", Food type: " + this.foodType
				+ ", Quantity avaialable: " + this.quantityAvailable
				+ ", unitPrice: " + unitPrice;
	}
}

class Tester {

	public static void main(String[] args) {
		Food foodOne = new Food();
		foodOne.setFoodName("Sandwich");
		foodOne.setCuisine("Continental");
		foodOne.setFoodType("Veg");
		foodOne.setQuantityAvailable(100);
		foodOne.setUnitPrice(10);

		// Comment the toString() in the Food class and execute the code
		System.out.println(foodOne);
	}
}
```
Food -> Food name: Sandwich, Cuisine: Continental, Food type: Veg, Quantity avaialable: 100, unitPrice: 10.0

Output if tosString commented : Food@7aajnhb55

# Wrapper Class
The primitive data types in Java do not inherit the Object class as they are not classes but sometimes, it is required to convert data types into objects in Java programming.

To convert data types into objects and to inherit the Object class, Java has Boolean, Character, Integer, Long, Float and Double classes which are called as Wrapper Class.

Wrapper classes help in representing the primitive data types as an object. They form a wrapping around the primitive values to represent them as objects.

They belong to the java.lang package as part of the Java library.

Wherever, the data type is required as an object, the objects of the Wrapper classes can be used. Wrapper classes include methods to unwrap the object and give back the data type.

### wrapper classes tryout

```
class Tester {

	public static void main(String[] args) {

		// Comparison of Integer objects
		Integer x = 5;
		Integer y = new Integer(5); // int data converted to Integer object
		System.out.println("x == y: " + (x == y));
		System.out.println("x.equals(y): " + x.equals(y));

		// Wrap the primitive content into wrapper class objects
		Integer number = Integer.valueOf(x);
		System.out.println("Wrapping x to its Integer: " + number);
		System.out.println("Check if number is of type Integer: "
				+ (number instanceof Integer));

		// Wrappers can be used to convert numeric strings to numeric datatypes
		String numStr = "123";
		int numInt = Integer.parseInt(numStr);
		System.out.println("String to integer: " + numInt);

		String doubleStr = "123.45";
		double numDouble = Double.parseDouble(doubleStr);
		System.out.println("String to double: " + numDouble);

		// Type casting cannot be used to convert any wrapper type to another,
		// it will give compilation error
		/* Uncomment the below code and observe the output*/
// 		Long phoneNoLong = (Long) new Integer(44281234); 

		// We can make use of methods like intValue(), byteValue(),
		// floatValue(), etc. for conversion
		Integer phoneNo = 44281234;
		// longValue() converts the Integer value to long data type
		Long phoneNoLong = phoneNo.longValue(); 
		System.out.println("Integer to Long: " + phoneNoLong);

		// Converts the Integer object to binary value
		System.out.println("Integer 5 as binary string: "
				+ Integer.toBinaryString(5));
	}
}
```

# ABstract

Customer class in the SwiftFood app scenario has a payBill method. The implementation of this method completely depends on the type of customer. So, we implemented this method in all our customer types (child classes) by overriding the parent method.

Thus, the parent class method implementation doesn’t actually have any significance but it is necessary for all the child classes to provide a proper implementation for the method.

So, this means the parent class Customer will not have any implementation for the payBill method but we need to enforce that the child classes implement the payBill() method.

This can be enforced with the help of abstract keyword as shown below.

abstract public class Customer {
	// Instance variables and constructor
	public abstract double payBill(double totalPrice);
	// displayCustomerDetails()
	// updateDetails() overloaded methods
	// getter and setter methods
}

Here, the method payBill doesn’t have any implementation because it depends on the customer type, whether it is a guest, regular customer or premium customer.

Since it cannot have any implementation, it has been marked as abstract.

Since the method payBill is abstract in the Customer class, the class itself becomes incomplete and demands for a child class to complete it.

For marking the class as incomplete, abstract keyword is used with the class also. Any class extending this abstract class must provide the implementation of the abstract methods.

The abstract keyword signifies that something is not complete. It can be used with classes and methods.

An abstract method is a method without any definition, i.e., the body. The signature of an abstract method must be preceded by the abstract keyword.
```
public abstract double payBill(double totalPrice);
```
An abstract class is a class which is incomplete and cannot be instantiated. 
```
abstract public class Customer {}
```
Some points that you should be knowing about abstract class are:

- An abstract class encapsulates the common behaviors of all its child classes with the help of abstract methods

- Concrete (non-abstract) classes which extend an abstract class must implement all the abstract methods. Otherwise, they should be made abstract as well.

- If a class contains at least one abstract method, the class should be abstract.

- A class can be made abstract even without any abstract methods.

We know a parent class reference can refer to a child class object. So, if a reference belongs to an abstract class, you can be sure that the object it refers to will always be of its child type.

Thus, abstract classes enforce inheritance (since they can’t be instantiated)

and

abstract methods enforce overriding (since they are incomplete with no implementation)

# Abstract class and methods

```
abstract class GrandParent {
	abstract void display();
}

abstract class Parent extends GrandParent {	// Can we remove the abstract keyword from here?
	final void displayInParent() {
		System.out.println("In Parent");
	}
}

class Child extends Parent {
	void display() {
		System.out.println("Child completes Parent and GrandParent");
	}
}

final class GrandChild extends Child {
	void display() {
		System.out.println("In GrandChild");
		super.display();
	}
}

//Uncomment the code given below and observe
//class GreatGrandChild extends GrandChild { }		    

class Tester {
	public static void main(String[] args) {
		new GrandChild().display();
	}
}
```

# instanceOf tryout

The insatnceOf operator is used to test whether a refernce variable is an insatnce of the spicified type(class or subclass or interface)

```
abstract class Employee{
    private String employeeId;
    private String name;
    private static int counter;
    
    static{
        counter=101;
    }
    
    public Employee(String name){
        //Checking the type of the current instance
        if(this instanceof PermanentEmployee)
			employeeId="P"+counter++;
		else if(this instanceof ContractEmployee)
			employeeId="C"+counter++;
		setName(name);
    }
    
    public abstract void calculateSalary();
    
    public String getEmployeeId(){
        return employeeId;
    }
    
    public String getName(){
        return name;
    }
    
    public void setName(String name){
        this.name=name;
    }
}

class PermanentEmployee extends Employee{
    
    public PermanentEmployee(String name){
        super(name);
    }
    
    @Override
    public void calculateSalary(){
        System.out.println("Calculating salary of PermanentEmployee");
    }
    
    public void calculateBonus(){
        System.out.println("Calculating bonus of PermanentEmployee");
    }
}


class ContractEmployee extends Employee{
    
    public ContractEmployee(String name){
        super(name);
    }
    
    @Override
    public void calculateSalary(){
        System.out.println("Calculating salary of ContractEmployee");
    }

}

class SalarySlipGenerator{
    public void displaySalarySlip(Employee employee){
        employee.calculateSalary();
        //Checking if employee is an instance of PermanentEmployee
        if(employee instanceof PermanentEmployee){
            //Type casting parent class reference to child class for accessing child class method
            PermanentEmployee permanentEmployee=(PermanentEmployee)employee;
			permanentEmployee.calculateBonus();
        }
    }
}


class Tester{
    public static void main(String[] args) {
        PermanentEmployee permanentEmployee=new PermanentEmployee("Angie");
        System.out.println("Details of permanent employee");
        System.out.println("Employee Id: "+permanentEmployee.getEmployeeId());
        System.out.println("Name: "+permanentEmployee.getName());
    
        System.out.println();
        
        ContractEmployee contractEmployee=new ContractEmployee("Roger");
        System.out.println("Details of contract employee");
        System.out.println("Employee Id: "+contractEmployee.getEmployeeId());
        System.out.println("Name: "+contractEmployee.getName());
    
        System.out.println();
    
        SalarySlipGenerator salarySlipGenerator=new SalarySlipGenerator();
        System.out.println("Salary of permanent employee");
        salarySlipGenerator.displaySalarySlip(permanentEmployee);
        
        System.out.println();
    
        System.out.println("Salary of contract employee");
        salarySlipGenerator.displaySalarySlip(contractEmployee);
    }
}
```

# Finals

we have used some constant values for mathematical calculations. For example, to calculate the area of circle we use the formula πr2 where π is a constant whose value is 3.14 and r is the radius of the circle.

In programming, we may encounter situations where we may have to create components that must remain constant, i.e., never change. In such cases, the final keyword can be used.

The final keyword can be used with classes, variables and methods. The details are diagrammatically shown below.

Also, observe the identifier naming convention for final fields.

- Variables : final field value cannot be changed once it is initialized i.e it becomes a consatnt

- Methods : final methods cannot be overridden in sub-class

- Classes : Cannot ve sub-clasess, it cannot be extended.

## Final avraible tryout

- the value of num cannot be changed. Errror code

```
class Demo {
	final int num = 10; // final variable

	public void changeNumber() {
		num = 20;
		System.out.println("The value of num is " + num);
	}
}

class Tester {

	public static void main(String args[]) {
		Demo demo = new Demo();
		demo.changeNumber();
	}
}
```

## Final methoud tryput

error throw cannot be orerride

```
class A {
	final public void example() {
		System.out.println("A Class Method");
	}
}

class B extends A {
	@Override
	public void example() {
		System.out.println("B Class Method");
	}

}

class Tester {
	public static void main(String[] args) {
		B obj = new B();
		obj.example();
	}

}
```

## Final M tryout

No error
```
class A {
	final void example() {
		System.out.println("Class A method");
	}
}

class B extends A {
	void demo() {
		System.out.println("Class B method");
	}
}

class Tester {
	public static void main(String[] args) {
		B obj = new B();
		obj.example();
	}

}

```

## Final class tryout

```
final class A {
}

class B extends A {
	void demo() {
		System.out.println("In class B");
	}
}

class Tester {
	public static void main(String args[]) {
		B obj = new B();
		obj.demo();
	}
}
```

## Blank Final Variable

If a final variable is not initialized during declaration, it is known as blank final variable. We can initialize a blank final variable only in the constructor, else there will be a compilation error. So, if you are marking a variable as final, it can be initialized only once either while declaring or in the constructor of the class.

```
class Demo {
	final int num; // blank final variable

	public Demo() {
		num = 10;
	}

	public void displayNumber() {
		System.out.println(num);
	}
}

class Tester {
	public static void main(String args[]) {
		Demo demo = new Demo();
		demo.displayNumber();
	}
}
```


# Interface

You know that the Premium customers are provided with a membership card using which they can redeem points. Such membership cards can be provided by several businesses to their customers and not just by SwiftFood app. This calls for setting a contract which can be followed by all the businesses who want to provide membership cards.

This setting up of contract can be implemented by using Interfaces in object oriented programming.

An interface is used to define a generic template which can be implemented by various classes.

It contains method signatures and constant declarations

The methods declared in an interface are implicitly public and abstract and the data fields are implicitly public, static and final, i.e., constants

An interface can extend more than one interface and a class can implement more than one interface. This can be used to simulate multiple inheritance in Java

A class can extend from only one class but can implement any number of interfaces

The implements keyword is used to implement an interface. The classes implementing an interface must implement all the specified methods. Otherwise, they should be made abstract

An interface creates a type. Hence, its reference can be used to refer to the objects of the classes which implement that interface. This leads to dynamic binding

Since Java 8, an interface can also have default and static methods. This is not discussed in this course

Observe the below code. The interface specifies the behaviors by declaring methods but does not provide the implementations. Using interface, we specify what is to be done without telling how. 

public interface PremiumCards {
	int WELCOME_POINTS = 100;
	double redeemPoints(double totalPrice);
	void addPoints(double money);
}

## Interface try

```
interface DemoOne {
	int number = 5;
}

interface DemoTwo extends DemoOne{
	void display();
}

class DemoClassOne implements DemoTwo {
	public void display() {
		System.out.println(number);
	}
}

class Tester {
	public static void main(String[] args) {
		DemoTwo obj = new DemoClassOne();
		obj.display();
	}
}
```

# Packages

- Just as books are cataloged and arranged in a library, it is important for us to organize our Java files. In order to follow a modular approach, a set of related classes and interfaces can be grouped together at one place called package.

- Packages help in organizing our Java files. It is a mechanism of grouping similar types of classes and interfaces collectively based on functionality.

## Adv:

Creating packages and grouping related documents together mainly have the following advantages:

Modularization: Real-life Java projects will have several hundreds of classes and other files. Using packages provides a good structure for projects. It becomes easier to locate the related classes which improve efficiency.

Re-usability: It provides re-usability. If a particular functionality of class has to be accessed in a different class of different package, then, you can just import the class into different packages and use it.

Name Conflicts: If there is a need for creating another class with the same name, then we can define two classes with the same name in different packages to avoid name collision.

Controlled Access: It provides access protection. Protected and default have package level access control. A protected member is accessible by classes in the same package and its sub-classes of the same or another package. A default member (without any access specifier) is accessible by classes in the same package only.

Data Encapsulation: They provide a way to hide classes, preventing other programs from accessing classes that are meant for internal use only.

Therefore, it is a good practice to use packages.

Packages can be divided into two categories:

1. Built-in Packages

2. User-Defined Packages

- Built-in Packages: Built-in packages or predefined packages are those that come along as a part of JDK (Java Development Kit). They consist of a huge number of predefined classes and interfaces that are part of Java API. Some of the commonly used built-in packages are java.lang, java.io, java.util, etc.

- User-Defined Packages: User-defined packages are those which are developed by users in order to group related classes, interfaces and sub-packages.

- A package in Java can be created either with the help of IDE or by using the package keyword as the first line of a Java file to specify the package of a class. There can be only one package statement in each source file and it applies to all classes or interfaces in the file.

- If a package statement is not used, then the Java files will be placed in the current default package.

- The naming convention for packages is to write the complete package in lowercase.

- Only public classes can be imported into different packages.

# Protected

- Variables, methods and constructors which are declared protected in the parent class can be accessed only by the sub classes in other packages or any class within the same package.

- The protected access modifier cannot be applied to classes and interfaces.

- Protected access modifier allows the child classes present in different packages to use the protected method or variable of the parent class while preventing other classes of the different package from doing so.

- Next, you would see how to access classes and files of one package in another package.

# Import

- import keyword is used to import built-in or user-defined packages into a Java source file so that a class can refer to another class that is in a different package.

- There are three ways to access the Java source file of one package in another package.

1. To import all the classes from a particular package:
```
import packagename.*;
```
If you use packagename.*, then all the classes and interfaces of the package will be accessible but the classes and interfaces present inside the sub packages will not be available for use.

2. To import only the class/classes you want to use:
```
import  packagename.classname;
```
If you import packagename.classname, then only the class with the name classname of the package with the name packagename will be available for use

3. Using a fully qualified name:
```
packagename.classname;
```
If you use a fully qualified name to import any class into your program, then only that particular class of the package will be accessible in your program, other classes in the same package will not be accessible. For this approach, there is no need to use the import statement but you will have to use the fully qualified name every time you are accessing the class or the interface. This is not a recommended approach.

# The table given below explains the accessibility of the different access modifiers.

										Private		Default 	Protected 	Public
Same class								YES			YES			YES			YES
Sub classess within the same package    NO 			YES 		YES			YES
Same package							NO			YES 		YES			YES
Sub classes in diffrent packages		NO 			NO			YES			YES
Different Packages						NO			NO			NO  		YES

To summarize:

Anything declared as public can be accessed from anywhere

Anything declared as private can be accessed only within that class

If access modifier is not mentioned, an element is accessible to all the classes in the same package

Anything declared as protected can be accessible to all the classes inside the same package and to the sub classes present in a different package

# Package Summary

- Packages help in organizing Java files by grouping similar Java files together.

- Every class is part of some package.

- When a package name is not specified, the classes are placed inside the default package.

- A class can have only one package statement but it can have more than one import package statements.

- The name of the package must be the same as the directory under which the file is saved.

- When importing another package, package declaration must be the first statement followed by package import.

# Exception :

The runtime errors shown previously are called as exceptions and the process of handling the exceptions is known as Exception Handling.

## Try catch

In order to handle exceptions, the first step is to identify the code which may generate exceptions. The set of statements that may generate an exception are enclosed in a block known as try block. The try block contains a set of statements where an exception can occur.

The second step is to handle those exceptions. In order to handle those exceptions which get raised in the try block, we use the catch block. A catch block is where you handle the exceptions, i.e., the catch block specifies what is to be done when an exception occurs.

A try block is always followed by a catch block.

Syntax:

try
{
     // statements that may cause an exception
}
catch (exceptionType e) ‏
{
     // error handling code
}

### Try catch tryout

```
class Student {
    private String name;
    private int[] marks;
    private float averageMarks;
    
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int[] getMarks() {
		return marks;
	}
	public void setMarks(int[] marks) {
		this.marks = marks;
	}
	public float getAverageMarks() {
		return averageMarks;
	}
	public void setAverageMarks(float averageMarks) {
		this.averageMarks = averageMarks;
	}
    
	public void calculateAverageMarks() {
		int sum=0;
		int totalSubjects=0;
		try {
		    for (int i = 0; i <marks.length;i++) {
			    sum+=marks[i];
		    }
		    this.averageMarks=sum/totalSubjects; //Exception will be thrown as the value of totalSubjects is 0 
		    System.out.println("Average Marks: "+ this.averageMarks);
		}
	    catch(ArithmeticException e) {
            //This block will execute only if any Arithmetic exception is thrown in try block
		    System.out.println("Divide by Zero exception occurred!");
	    }
	}
}

class Tester{
	public static void main(String[] args) {
		Student student1 = new Student();
		int[] marks = {96,65,76};
		student1.setMarks(marks);
		student1.calculateAverageMarks();
	}
}


```

# Multiple catch blocks

In the previous tryout, we have handled the issue of divide by zero exception by using the try-catch block.

Replace the calculateAverageMarks() in the previous tryout with the below method implementation. Try out the updated code and observe the output. 
```
public void calculateAverageMarks() {
	int sum = 0;
	int totalSubjects = 0;
	try {
		for (int i = 0; i <= marks.length; i++) {
			++totalSubjects;
			sum += marks[i];
		}
		this.averageMarks = sum / totalSubjects;
		System.out.println("Average Marks: " + this.averageMarks);
	} catch (ArithmeticException e) {
		System.out.println("Divide by Zero exception occurred!");
	}
}
```
In the previous tryout, we have handled the issue of divide by zero exception by using the try-catch block.

Replace the calculateAverageMarks() in the previous tryout with the below method implementation. Try out the updated code and observe the output. 
```
public void calculateAverageMarks() {
	int sum = 0;
	int totalSubjects = 0;
	try {
		for (int i = 0; i <= marks.length; i++) {
			++totalSubjects;
			sum += marks[i];
		}
		this.averageMarks = sum / totalSubjects;
		System.out.println("Average Marks: " + this.averageMarks);
	} catch (ArithmeticException e) {
		System.out.println("Divide by Zero exception occurred!");
	}
}
```
Array Indec out of range

his is because the present catch block can handle only ArithmeticException whereas the current implementation of calculateAverage() encounters ArrayIndexOutOfBoundsException. In order to resolve this exception, we have to create one more catch block having the exception type as ArrayIndexOutOfBoundsException.

In Java, a single try block can have several catch blocks associated with it. You can catch different exceptions in different catch blocks. When an exception occurs in the try block, one of the corresponding catch blocks that handles that particular exception executes. For example, if an arithmetic exception occurs in try block then the statements enclosed in the catch block for arithmetic exception executes.
```
catch(ArrayIndexOutOfBoundsException e) {
	//This block will only execute if any ArrayIndexOutOfBoundsException occurs in try block
	System.out.println("Array index out of range exception occurred!");
}	
```				 
After adding the above catch block in the calculateAverageMarks() method, the program will not display the system generated exception message. Instead, it will display the user-defined message.

### Need for generic catch block

Can we predict all the exceptions that can occur in a program?

It is nearly difficult to predict all the possible exceptions and write the corresponding catch blocks. Then how can we catch the exception for which we don’t have corresponding catch block?

Suppose we want to display the length of the student name in calculateAverage() and let us assume that studentName is not yet initialized.

This will result in NullPointerException.

### Generic catch block

In order to catch an exception for which the corresponding catch block is not present in the program, we can use the generic exception catch block.

Syntax:
```
catch(Exception e) {
	//This block can handle all types of exceptions
	System.out.println("Some error occurred");
}
```
The generic exception handler can handle all types of exceptions, therefore, it should be placed at the end of all the catch blocks.
```
catch(ArithmeticException e) {
	//This block will only execute if any Arithmetic exception occurs in try block
	System.out.println("Divide by Zero exception occurred!");
}
catch(ArrayIndexOutOfBoundsException e) {
	//This block will only execute if any ArrayIndexOutOfBoundsException occurs in try block
	System.out.println("Array index out of range exception occurred!");
}
catch( Exception e) {
	//This block will handle all types of exceptions that occur in try block
	System.out.println("Some error occurred!");
}
```

### Placement of geenric catch block

If you will try to place the generic catch block at any other place (start or middle) of the catch blocks, then it will result in a compilation error.

```
catch(ArithmeticException e) {
	//This block will only execute if any Arithmetic exception occurs in try block
	System.out.println("Divide by Zero exception occurred!");
}
catch(Exception e) {
	//This block will handle all types of exceptions that occur in try block
	System.out.println("Some error occurred!");
}
catch(ArrayIndexOutOfBoundsException e) {
	//This block will only execute if any ArrayIndexOutOfBoundsException occurs in try block
	System.out.println("Array index out of range exception occurred!");
}
```


# Nested try-Catch

When a try-catch block is present inside another try block then it is called a nested try-catch block. 

The syntax of nested try-catch is given below:
```
//main try block
try{
    statement 1;
    statement 2;
    //nested try-catch block
    try{
        statement 3;
    }
    catch(Exception ex){
        //exception message
    }
}
catch(Exception ex){
    //exception message
}
```
If the inner catch block is not able to handle the exception raised in the inner try block, then the execution moves to the outer catch block.

Take a look at the below code to understand how nested try-catch works.
```
public void calculateAverageMarks() {
		int sum=0;
		int totalSubjects=0;
		//outer try block
		try {
			//inner try block
			try {
				for (int i = 0; i <marks.length;i++) {
				    sum+=marks[i];
			    }
				this.averageMarks=sum/totalSubjects;//Exception will be raised as totalSubjects is 0 
				System.out.println("Average Marks: "+ this.averageMarks);
			}
			//inner catch block
			catch(ArithmeticException e) {
		            //This block will only execute if any Arithmetic exception occurs in try block
				    System.out.println("Divide by Zero exception occurred!");
			    }
			catch(ArrayIndexOutOfBoundsException e) {
				//This block will only execute if any ArrayIndexOutOfBoundsException occurs in try block
				System.out.println("Array index out of range exception occurred!");
			} 
		}
		//outer catch block
		catch(Exception e) {
			//This block will handle all types of exceptions that occur in try block
			System.out.println("Some error occurred!");
		}
	   
}
```

## Nested try catch tryout

```
class Student {
    private String name;
    private int[] marks;
    private float averageMarks;
    
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int[] getMarks() {
		return marks;
	}
	public void setMarks(int[] marks) {
		this.marks = marks;
	}
	public float getAverageMarks() {
		return averageMarks;
	}
	public void setAverageMarks(float averageMarks) {
		this.averageMarks = averageMarks;
	}
    
	public void calculateAverageMarks() {
		int sum=0;
		int totalSubjects=0;
		//outer try block
		try {
			//inner try block
			try {
				for (int i = 0; i <marks.length;i++) {
				    sum+=marks[i];
			    }
				this.averageMarks=sum/totalSubjects;//Exception will be raised as totalSubjects is 0 
				System.out.println("Average Marks: "+ this.averageMarks);
			}
			//inner catch block
			catch(ArithmeticException e) {
		            //This block will only execute if any Arithmetic exception occurs in try block
				    System.out.println("Divide by Zero exception occurred!");
			    }
			catch(ArrayIndexOutOfBoundsException e) {
				//This block will only execute if any ArrayIndexOutOfBoundsException occurs in try block
				System.out.println("Array index out of range exception occurred!");
			} 
		}
		//outer catch block
		catch(Exception e) {
			//This block will handle all types of exceptions that occur in try block
			System.out.println("Some error occurred!");
		}
	   
	}
}

class Tester{
	public static void main(String[] args) {
		Student student1 = new Student();
		int[] marks = {96,65,76};
		student1.setMarks(marks);
		student1.calculateAverageMarks();
	}
}


```

## Finally

A finally block contains all the crucial statements that must be executed irrespective of whether an exception occurs or not. The statements present in this block will always execute regardless of whether an exception occurs in a try block or not. finally block is optional and can be used only with a try-catch block.

Syntax:
```
try{
     //Statements that may cause an exception
}
catch (ExceptionType e) ‏{
     //Error handling code
}
finally {
	//Statements that must be executed 
}
```

## Finally Tryout
```
class Student {
	private String name;
	private int[] marks;
	private float averageMarks;

	public String getName() {
		return name;
	}

	public void setStudentName(String name) {
		this.name = name;
	}

	public int[] getMarks() {
		return marks;
	}

	public void setMarks(int[] marks) {
		this.marks = marks;
	}

	public float getAverageMarks() {
		return averageMarks;
	}

	public void setAverageMarks(float averageMarks) {
		this.averageMarks = averageMarks;
	}

	public void calculateAverageMarks() {
		int sum = 0;
		int totalSubjects = 0;
		try {
			// Comment the below line and observe the output
			System.out.println("Name length : " + this.name.length());
			for (int i = 0; i < marks.length; i++) {
				++totalSubjects;
				sum += marks[i];
			}
			this.averageMarks = sum / totalSubjects;
			System.out.println("Average Marks: " + this.averageMarks);
		}

		catch (ArithmeticException e) {
			/*This block will only execute if any 
			 * Arithmetic exception occurs in try block
			 */
			System.out.println("Divide by Zero exception occurred!");
		}

		catch (ArrayIndexOutOfBoundsException e) {
			/*This block will only execute if any 
			 * ArrayIndexOutOfBoundsException occurs in try block
			 */
			System.out.println("Array index out of range exception occurred!");
		} catch (Exception e) {
			/* This block will handle all types of exceptions 
			 * that occur in try block
			 */
			System.out.println("Some error occurred!");
		} finally {
			/*This block will be executed irrespective of 
			 * whether an exception occurs or not
			 */
			System.out.println("Thank you for using the application!");
		}
	}
}

class Tester {
	public static void main(String[] args) {
		Student student1 = new Student();
		int[] marks = { 96, 65, 76 };
		student1.setMarks(marks);
		student1.calculateAverageMarks();
	}
}

```

## Types of Exceptions

There are two different types of exceptions in Java:

1. Checked Exception

2. Unchecked Exception

1. Checked Exception

All exceptions other than runtime exceptions are known as Checked Exceptions as the compiler checks them during compilation to see whether the programmer has handled them or not. If these exceptions are not handled/declared in the program, you will get a compilation error. In this case, the programmers are forced to either handle these exceptions or declare to allow their propagation.

 E.g. - SQLException, IOException, etc. are Checked Exceptions

2. Unchecked Exception

Unchecked exceptions are runtime exceptions. These exceptions are not checked at compile-time. So, the compiler does not check whether the programmer has handled them or not. In this case, the programmers are not forced to handle or declare their propagation.

E.g. - ArithmeticException, NullPointerException, ArrayIndexOutOfBoundsException, etc. are Unchecked Exceptions


# Throw

Let us consider a scenario of populating the marks of 3 subjects for a student. Let us assume that the programmer has wrongly given one subject’s marks as -65.

Is it possible to have marks as -65?

Obviously not!

Logically, this should not be the value of the accepted marks but the previous program will not raise any exception and average marks will be calculated with the wrong value.

Why does the program not raise an exception in this case?

The exception does not get raised because this marks being invalid is not one of the exception types that Java has defined. Here, if we want to raise an exception for negative marks, then we have to raise it manually. 

In Java, we can define our own set of conditions or rules and throw an exception explicitly using throw keyword.

For example, we can throw the exception if the value of the marks is negative using throw keyword.

Syntax:
```
throw new <exceptionclass>("error message");
```
This is possible with any object of type Throwable.

### Throw tryout

```
class Student {
	private String name;
	private int[] marks;
	private float averageMarks;

	public String getName() {
		return name;
	}

	public void setStudentName(String name) {
		this.name = name;
	}

	public int[] getMarks() {
		return marks;
	}

	public void setMarks(int[] marks) {
		this.marks = marks;
	}

	public float getAverageMarks() {
		return averageMarks;
	}

	public void setAverageMarks(float averageMarks) {
		this.averageMarks = averageMarks;
	}

	public void calculateAverageMarks() {
		int sum = 0;
		int totalSubjects = 0;
		try {
			for (int i = 0; i < marks.length; i++) {
				if (marks[i] < 0) {
					// Throwing exception manually in case of negative marks
					// value
					throw new Exception("Marks must not be negative!");
				}
				++totalSubjects;
				sum += marks[i];
			}
			this.averageMarks = sum / totalSubjects;
			System.out.println("Average Marks: " + this.averageMarks);
		}

		catch (ArithmeticException e) {
			// This block will only execute if any Arithmetic exception occurs
			// in try block
			System.out.println("Divide by Zero exception occurred!");
		}

		catch (ArrayIndexOutOfBoundsException e) {
			// This block will only execute if any
			// ArrayIndexOutOfBoundsException occurs in try block
			System.out.println("Array index out of range exception occurred!");
		} catch (Exception e) {
			// This block will handle all the types of exceptions that occur in
			// try block
			// Error message is being displayed using getMessage() of Exception
			// class
			System.out.println(e.getMessage());

		} finally {
			// This block will be executed irrespective of whether an exception
			// has occurred or not
			System.out.println("Thank you for using the application!");
		}
	}
}

class Tester {
	public static void main(String[] args) {
		Student student1 = new Student();
		int[] marks = { 96, -65, 76 };
		student1.setMarks(marks);
		student1.calculateAverageMarks();
	}
}

```

## User defined Exceotion
In the previous try out, the negative marks exception was of type Exception. It would have been better if we could have differentiated the negative marks exception the way we were able to differentiate ArithmeticException from ArrayIndexOutOfBoundsException. 

To make an application more flexible and manageable, Java allows us to have our own custom exceptions. This helps in working with specialized exceptions rather than a general one.

We can create a user-defined exception class by extending the Exception class:

Syntax:
```
class NegativeMarksException extends Exception  {
	// Message
}
```
We can also set a message using the parameterized constructor.
```
class NegativeMarksException extends Exception {
	public NegativeMarksException(String message) {
		super(message);// The message is being passed to the parent class
			           // constructor as the detailed message for the exception
	}
}
```
Now instead of using the system defined exception, we can use user-defined exceptions while throwing the exception.

## U D E Tryout
```
class NegativeMarksException extends Exception {
	public NegativeMarksException(String message) {
		super(message);
	}
}

class Student {
	private String name;
	private int[] marks;
	private float averageMarks;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int[] getMarks() {
		return marks;
	}

	public void setMarks(int[] marks) {
		this.marks = marks;
	}

	public float getAverageMarks() {
		return averageMarks;
	}

	public void setAverageMarks(float averageMarks) {
		this.averageMarks = averageMarks;
	}

	public void calculateAverageMarks() {
		int sum = 0;
		int totalSubjects = 0;
		try {
			for (int i = 0; i < marks.length; i++) {
				if (marks[i] < 0) {
					// Throwing User-defined exception in case of negative marks
					// value
					throw new NegativeMarksException(
							"Marks must not be negative!");
				}
				++totalSubjects;
				sum += marks[i];
			}
			this.averageMarks = sum / totalSubjects;
			System.out.println("Average Marks: " + this.averageMarks);
		}

		catch (ArithmeticException e) {
			// This block will execute only if any Arithmetic exception occurs
			// in try block
			System.out.println("Divide by Zero exception occurred!");
		}

		catch (ArrayIndexOutOfBoundsException e) {
			// This block will execute only if any
			// ArrayIndexOutOfBoundsException occurs in try block
			System.out.println("Array index out of range exception occurred!");
		} catch (NegativeMarksException e) {
			// This block will execute only if any NegativeMarksException occurs
			// in try block
			System.out.println(e.getMessage());
		} catch (Exception e) {
			// This block will handle all the types of exceptions that occur in
			// try block
			System.out.println(e.getMessage());

		} finally {
			// This block will be executed irrespective of whether an exception
			// has occurred or not
			System.out.println("Thank you for using the application!");
		}
	}
}

class Tester {
	public static void main(String[] args) {
		Student student1 = new Student();
		int[] marks = { 96, -65, 76 };
		student1.setMarks(marks);
		student1.calculateAverageMarks();
	}
}

```

# Where to handle exception

Till now we have defined the try-catch block in the method definition where the exceptions are getting raised. Instead of writing a try-catch block inside the method definition, we can write the method call also inside the try-catch block.

If the exceptions are not handled in the method definition, then it propagates to the place where you have called that method automatically. Observe the below code.
```
class Student {
	private String name;
	private int[] marks;
	private float averageMarks;
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int[] getMarks() {
		return marks;
	}
	public void setMarks(int[] marks) {
		this.marks = marks;
	}
	public float getAverageMarks() {
		return averageMarks;
	}
	public void setAverageMarks(float averageMarks) {
		this.averageMarks = averageMarks;
	}
	public void calculateAverageMarks() {
		int sum = 0;
		int totalSubjects = 0;
		for (int i = 0; i <= marks.length; i++) {
			if (marks[i] < 0) {
				// throw new Exception("Marks must not be negative");
			}
			++totalSubjects;
			sum += marks[i];
		}
		this.averageMarks = sum / totalSubjects;
		System.out.println("Average Marks is : " + this.averageMarks);
	}
}
class Tester {
	public static void main(String[] args) {
		Student student1 = new Student();
		int[] marks = { 96, 65, 76 };
		student1.setMarks(marks);
		try {
			student1.calculateAverageMarks();
		} catch (ArithmeticException e) {
			// This block will execute only if any Arithmetic exception occurs
			// in try block
			System.out.println("Divide by Zero exception occurred!");
		}
		catch (ArrayIndexOutOfBoundsException e) {
			// This block will execute only if any
			// ArrayIndexOutOfBoundsException occurs in try block
			System.out.println("Array index out of range exception occurred!");
		} catch (Exception e) {
			// This block will handle all the types of exceptions that occur in
			// try block
			System.out.println(e.getMessage());
		} finally {
			// This block will be executed irrespective of whether an exception
			// has occurred or not
			System.out.println("Thank you for using the program!");
		}
	}
}
```

# throws

You have seen how to handle exceptions while calling the method as well as in the called method. You will now see how to propagate exceptions from the calling environment to the called environment.

Uncomment the exception which is getting raised due to negative marks. Here the exception is getting raised with the help of throw keyword. This will also result in an Unresolved compilation problem.

If a method does not handle a checked exception, the method must declare it using the throws keyword. The throws keyword appears at the end of a method's signature.

Syntax:
```
public void calculateAverageMarks() throws Exception {
	//throw checked exception 
}
```
A method can declare that it throws more than one exception, in which case the exceptions are declared in a list separated by commas.
```
public void calculateAverageMarks() throws 
ArithmeticException,ArrayIndexOutOfBoundsException,NullPointerException {
	//throw checked exception 
}
```

### throws tryout

```
class NegativeMarksException extends Exception {
	public NegativeMarksException(String message) {
		super(message);
	}
}

class Student {
	private String name;
	private int[] marks;
	private float averageMarks;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public int[] getMarks() {
		return marks;
	}

	public void setMarks(int[] marks) {
		this.marks = marks;
	}

	public float getAverageMarks() {
		return averageMarks;
	}

	public void setAverageMarks(float averageMarks) {
		this.averageMarks = averageMarks;
	}

	public void calculateAverageMarks() throws Exception {
		int sum = 0;
		int totalSubjects = 0;

		for (int i = 0; i < marks.length; i++) {
			if (marks[i] < 0) {
				throw new NegativeMarksException("Marks must not be negative!");
			}
			++totalSubjects;
			sum += marks[i];
		}
		this.averageMarks = sum / totalSubjects;
		System.out.println("Average Marks: " + this.averageMarks);
	}
}

class Tester {
	public static void main(String[] args) {
		Student student1 = new Student();
		int[] marks = { 96, -65, 76 };
		student1.setMarks(marks);
		try {
			student1.calculateAverageMarks();
		} catch (ArithmeticException e) {
			// This block will execute only if any Arithmetic exception occurs
			// in try block
			System.out.println("Divide by Zero exception occurred!");
		}

		catch (ArrayIndexOutOfBoundsException e) {
			// This block will execute only if any
			// ArrayIndexOutOfBoundsException occurs in try block
			System.out.println("Array index out of range exception occurred!");
		} catch (NegativeMarksException e) {
			// This block will execute only if any NegativeMarksException occurs
			// in try block
			System.out.println(e.getMessage());
		} catch (Exception e) {
			// This block will handle all the types of exceptions that occur in
			// try block
			System.out.println("Some error occurred!");
		} finally {
			// This block will be executed irrespective of whether an exception
			// has occurred or not
			System.out.println("Thank you for using the application!");
		}
	}
}

```

# Exception Summary

An Exception is an unwanted event that interrupts the normal flow of the program.

In Java, exception is basically of two types – Checked and Unchecked Exception.

Exception can be handled with try, catch and finally block.

A single try block can have any number of catch blocks.

A single try block must be followed by at least one catch block or finally block.

A generic catch block can handle all the exceptions.

If no exception occurs in try block, then the catch blocks are completely ignored.

Generic catch block must be the last catch block of try-catch.

Finally block is optional.

A finally block gets executed irrespective of whether an exception occurs or not.

A finally block must be associated with a try block, you cannot use finally without a try block.

An exception in the finally block behaves exactly like any other exception.

Exception can be raised explicitly also by using throw keyword.

If you are propagating the exception to the method call using throw, then method must be declared with throws keyword.

Programmer can define their own exception, i.e., create User-defined exception.

User-defined exception must extend Exception class.

 
 # Introduction to Junit

 As you have already seen, testing is an essential part while developing an application or even a small code. Testing ensures that code is functioning properly for all possible cases.

Manual testing of code is an error prone process and time consuming, especially when it comes to larger applications with increased code size. Thus, performing automated testing is more reliable and saves lot of time.

There are several frameworks available for automating unit tests. JUnit and TestNG are among the popular ones for Java.

In this course, you will be using JUnit.

JUnit is an open-source unit testing framework for Java programming language. It provides classes to write and run automated tests.

Features of JUnit

open source framework used for writing and running tests

less complex and takes less time

provides immediate feedback

shows test progress

Intro

We need JARs for performing JUnit testing.

Java Archive (JAR) is a file containing packaged class files and associated resources. JARs are usually used to distribute applications or libraries. Projects which needs the content of an external JAR need to have the JAR included in their build path.

The following JARs are required for JUnit testing. 

junit-4.12.jar

hamcrest-core-1.3.jar

# Regular Expression

A regular expression (or regex in short) is a sequence of characters that forms a search pattern. It is composed of various symbols and characters and is mainly used in pattern matching for searching and editing. It helps in providing a pattern against which a string can be matched.

### RE try1

```
class Tester {
	public static void main(String args[]) {
		String regex1 = "Welcome.*";
		String str1 = "Welcome to India";

		String regex2 = "Welcome to (India|Mysore)";
		String str2 = "Welcome to Mysore";

		String regex3 = "[^Welcome]";
		String str3 = "1";

		System.out.println(str1.matches(regex1));
		System.out.println(str2.matches(regex2));
		System.out.println(str3.matches(regex3));

	}
}
```

### Re try 2

```
class Tester {
	public static void main(String args[]) {
		String regex1 = "[\\w]+ [\\w]+ [\\d]+";
		String str1 = "Java Training 123";

		String regex2 = "[\\w]+ [\\t] [\\w]+";
		String str2 = "Java 	 Training";

		String regex3 = "[\\w]+ [^\\w]+ [\\d]+";
		String str3 = "Java Training 123";

		String regex4 = "[\\D]+ [\\W]+";
		String str4 = "Java *";

		System.out.println(str1.matches(regex1));
		System.out.println(str2.matches(regex2));
		System.out.println(str3.matches(regex3));
		System.out.println(str4.matches(regex4));

	}
}
```

### Password validation
```
class Tester {
	public static boolean isValidPassword(String password) {
		boolean flag = false;
		String regex = "[A-Za-z]{8,10}[0-9]{4}";

		if (password.matches(regex)) {
			flag = true;
		}
		return flag;
	}

	public static void main(String[] args) {
		String password = "gftdrstr8645";
		System.out.println("The password of the customer is " + password);
		if (isValidPassword(password))
			System.out.println("The password is valid!");
		else
			System.out.println("The password is not valid!");
	}
}
```
 

# Linkedin List

- Java Collections framework also provides LinkedList class which removes the need of creating your own class for implementing a linked list. 

- LinkedList class implements the List interface as shown below.

- A linked list can be created as shown below.

```
List<String> myList = new LinkedList<String>();
//or
LinkedList<String> myList = new LinkedList<String>();
```

- Methods:
1. void add(int index, E element) - insert an elemnet at a spcified position
2. bool add(E element) - insert at the end
3. clear() - remove all elements
4. bool contains(obj o) - return true if list contains the specified obj
5. E get(int index) - return the element at a specified index
6. int indexOf(object o) - return the index of the first occurance of the specified obj else return -1 if LL is empty
7. bool remove(object o) - remove the 1 occurance
8. E set(int index, E element) - replace the elemst
9. Object[] toArray() - return an array conatining all the elements in the list
10. int size() - returns number of element

- Methods in LinkedList - Tryout

```
import java.util.List;
import java.util.LinkedList;

class EuropeTrip {

	public static void main(String args[]) {
		// Creating a LinkedList
		List<String> cities = new LinkedList<String>();

		// Adding elements
		cities.add("Milan");
		cities.add("Venice");
		cities.add("Munich");
		cities.add("Vienna");

		// Displaying elements
		System.out.println(cities);

		// Inserting elements
		cities.add(3, "Prague");
		System.out.println(cities);

		// Removing elements
		cities.remove("Munich");
		System.out.println(cities);

		// Replacing element
		cities.set(2, "Berlin");
		System.out.println(cities);

		// Displaying size
		System.out.println(cities.size());

		// Checking if an element is present
		System.out.println(cities.contains("Paris"));

		// Getting element at specific position
		System.out.println(cities.get(0));

		// Clearing the elements from the LinkedList
		cities.clear();
		System.out.println(cities);

		// Try to test the other methods of the LinkedList class
	}
}
```

# Queue Interface

- Queue is a collection used to hold multiple elements prior to processing.

- It is an interface available in java.util package and extends java.util.Collection interface.
Just like List, Queue is a collection of ordered elements (or objects) but it performs insertion and removal operations differently.

1. Queue represents an ordered list of elements

2. Queue supports all methods of Collection interface

3. All queues support insertion at the tail of the queue and removal from the head of the queue, except Deque

4. Deques are queues but they support element insertion and removal at both ends

- Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner. Among the exceptions are 

1. Priority queues, which order elements according to a supplied comparator, or the elements' natural ordering

2. LIFO queues (or stacks) which order the elements according to LIFO (last-in-first-out)

- Queue implementations generally do not allow insertion of null elements, although some of them do not prohibit insertion of null. It is advisable not to insert null into a Queue as null is returned by the poll method when the queue contains no elements.

- Queue supports all operations supported by Collection interface and also provides additional insertion and extraction operations.

- Each of these operations exists in two forms.

1. One set of operations throw an exception if the operation fails

2. The other set of operations return a special value (either null or false) if the operation fails

Operations			Throw Exception 	Returning Special Value

Insert				add 				offer
Remove 				remove				poll
Examine				element				peek

QUEUE INTERFACE

1. Particular orderd is maintained
2. Typically FIFO orders
3. Add elements from front of queue

METHODS
1. For addinng elemnts:
boolean add(obj) - exception when size is full
boolean offer(obj) - no exception but return false

2. For removing 
E remove - exception when size is empty - NOSUCHELEMENT
E poll - No exception but return null

3. For accessing front most element
E element() - Exception when q is empty
E peek() - No exception but returns null

push()
pop()

# Deque Interface

Deque is a linear collection that supports element insertion and removal at both ends. This interface extends the Queue interface.

The name deque is short for "double ended queue" and is usually pronounced "deck".

It supports capacity restricted deques as well as those with no fixed size limit.

Deque can be instantiated as:
```
Deque<String> deque = new ArrayDeque<>();

```

ArrayDeque class is the implementation of the Deque interface.

Unlike queue, you can add or delete the elements from both the ends through ArrayDeque.

Using this ArrayDeque class, both queue and stack can be implemented.

You will now see the implementation of queue and stack using ArrayDeque class.

# Queue using ArrayDeque:
```
import java.util.Deque;
import java.util.ArrayDeque;

class Tester{

	public static void main(String[] args) {

		Deque<String> queue = new ArrayDeque<String>();	// no restrictions in capacity
		queue.add("Joe");
		queue.add("Jack");
		queue.add("Eva");
		queue.add("Mia");
		queue.add("Luke");

		System.out.println("People in queue - After addition of 5 people");
		for (String str : queue) {
			System.out.println(str);
		}
		
		queue.remove();
		queue.remove();
		queue.remove();
		
		System.out.println("\nPeople in queue - After removal of 3 people");
		for (String str : queue) {
			System.out.println(str);
		}
		
		System.out.println();
		System.out.println("Head of the queue using element() - "+queue.element());
		System.out.println("Head of the queue using peek() - "+queue.peek());
		queue.remove();
		queue.remove();
		
		// new person added to the empty queue using offer()
		queue.offer("Emma");
		
		// newly added person removed using poll()
		queue.poll();
		
		System.out.println();
		System.out.println("Removing the head of the queue using poll when queue is empty - "+queue.poll());	// returns null since queue is empty		
		
		System.out.println("Head of the queue using peek() when queue is empty - "+queue.peek());	// returns null since queue is empty
		
	    /* Uncomment the lines of code given below one at a time and observe the output */
        //System.out.println("Head of the queue using element() when queue is empty - "+queue.element());	// throws NoSuchElementException since queue is empty
		
        //System.out.println("Removing the head of the queue using remove() when queue is empty");
        //queue.remove();		// throws NoSuchElementException since queue is empty

	}
}
```

Stack using ArrayDeque

```
import java.util.Deque;
import java.util.ArrayDeque;

class Tester {

	public static void main(String[] args) {

		Deque<Integer> stack = new ArrayDeque<Integer>();	// no restrictions in capacity
		stack.push(1);
		stack.push(2);
		stack.push(3);
		stack.push(4);
		stack.push(5);

		System.out.println("Numbers in stack - After addition of 5 values");
		for (Integer val : stack) {
			System.out.println(val);
		}
		
		stack.pop();
		stack.pop();
		stack.pop();
		
		System.out.println("\nNumbers in stack - After removal of 3 values");
		for (Integer val : stack) {
			System.out.println(val);
		}
		
		System.out.println();
		System.out.println("Top of the stack using peek() - "+stack.peek());
		
		stack.pop();
		stack.pop();
		
		//Uncomment the below code and observe the output
        //System.out.println("Trying to remove the element from the top of the stack using pop() when stack is empty - "+stack.pop());	// throws NoSuchElementException since stack is empty		
	
	}
}
```



Interface:
Methods :
public and abstract
Java 8 - default and static

Field :
public static final

Interface extend multiple interface

class can extend only one class
class can implements multiple interface

